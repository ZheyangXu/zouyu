# 概要

## 简介

MuJoCo 是"多关节动力学与接触"(Multi-Joint dynamics with Contact)的缩写。它是一款通用物理引擎，旨在促进机器人学、生物力学、图形和动画、机器学习以及其他需要快速准确模拟关节结构与环境交互的领域的研究与开发。MuJoCo 最初由 Roboti LLC 开发，于2021年10月被 DeepMind 收购并免费提供，并于2022年5月实现开源。MuJoCo 代码库可在 GitHub 的 google-deepmind/mujoco 仓库中获取。

MuJoCo 是一个面向研究人员和开发者的 C/C++ 库，提供 C 语言应用程序接口。其运行时模拟模块经过优化以实现最高性能，并在内置 XML 解析器和编译器预分配的低级数据结构上运行。用户可以使用原生的 MJCF 场景描述语言（一种设计得尽可能人类可读和可编辑的 XML 文件格式）定义模型。该库还支持加载 URDF 模型文件，并包含通过 OpenGL 渲染的原生图形界面进行交互式可视化。此外，MuJoCo 还提供大量用于计算物理相关量的实用功能。

MuJoCo 可用于实现基于模型的计算，如控制合成、状态估计、系统识别、机构设计、通过逆向动力学进行数据分析，以及为机器学习应用进行并行采样。它也可以作为更传统的模拟器使用，包括用于游戏和交互式虚拟环境。

## 核心功能

MuJoCo 具有众多特性，以下是其最显著的功能：

* 广义坐标与现代接触动力学的结合

    传统物理引擎通常分为两类。机器人学和生物力学引擎使用高效且精确的递归算法，基于广义坐标或关节坐标系统。然而，这类引擎要么忽略接触动力学，要么依赖于需要极小时间步长的传统弹簧-阻尼方法。游戏引擎则采用更现代的方法，通过求解优化问题来计算接触力。但它们往往使用过度指定的笛卡尔表示法，通过数值方法施加关节约束，这在复杂的运动结构中会导致不准确性和不稳定性。MuJoCo 是第一个将两种方法优势结合的通用引擎：在广义坐标下进行模拟，同时采用基于优化的接触动力学。其他模拟器最近也开始采用 MuJoCo 的方法，但由于它们的设计初衷不同，这种适配通常无法与其所有功能兼容。习惯于游戏引擎的用户可能会初始觉得广义坐标不太直观，详见下文"说明"部分。

* 柔性、凸性且可解析求逆的接触动力学

    在现代接触动力学方法中，摩擦接触产生的力或冲量通常被定义为线性或非线性互补问题(LCP 或 NCP)的解，这两种问题都是 NP 难的。MuJoCo 基于不同的接触物理学公式，将问题简化为凸优化问题，详见"计算"章节。我们的模型允许柔性接触和其他约束，并具有唯一定义的逆解，便于数据分析和控制应用。用户可选择不同的优化算法，包括一种可处理椭圆摩擦锥的投影高斯-赛德尔方法的推广。求解器统一处理各种约束，包括摩擦接触（含扭转和滚动摩擦）、无摩擦接触、关节和肌腱限制、关节和肌腱中的干摩擦，以及各种等式约束。

* 肌腱几何

    MuJoCo 能够建模肌腱的三维几何结构——这些肌腱是遵循包裹和经由点约束的最小路径长度弦。该机制类似于 OpenSim 中的机制，但实现了更受限的闭合形式包裹选项以加速计算。它还提供机器人学特有的结构，如滑轮和耦合自由度。肌腱可用于驱动，也可用于对肌腱长度施加不等式或等式约束。

* 通用驱动模型

    设计一个足够丰富的驱动模型，同时使用与模型无关的 API 是一项挑战。MuJoCo 通过采用抽象驱动模型实现了这一目标，该模型可以具有不同类型的传动、力生成和内部动态特性（即使整体动力学成为三阶的状态变量）。这些组件可以实例化，以统一的方式建模电机、气动和液压缸、PD 控制器、生物肌肉等多种驱动器。

* 可重构的计算流程

    MuJoCo 有一个顶层步进函数 mj_step，它运行整个前向动力学并推进模拟状态。然而，在许多超出模拟的应用中，能够运行计算流程中的选定部分是有益的。为此，MuJoCo 提供了大量可以任意组合设置的标志，允许用户根据需要重新配置流程，除了通过选项选择算法和算法参数外。此外，许多低级函数可以直接调用。用户定义的回调可以实现自定义力场、驱动器、碰撞例程和反馈控制器。

* 模型编译
    如前所述，用户在称为 MJCF 的 XML 文件格式中定义 MuJoCo 模型。然后，内置编译器将此模型编译成针对运行时计算优化的低级数据结构 mjModel。编译后的模型也可以保存为二进制 MJB 文件。

* 模型与数据分离
    MuJoCo 在运行时将模拟参数分为两个数据结构（C 结构体）：

    - `mjModel` 包含模型描述，预期保持不变。其中嵌入了包含模拟和可视化选项的其他结构，这些选项需要偶尔更改，但这由用户完成。
    - `mjData` 包含所有动态变量和中间结果。它用作一个暂存区，所有函数在其中读取输入并写入输出——这些输出随后成为模拟流程中后续阶段的输入。它还包含一个预分配和内部管理的堆栈，因此运行时模块在模型初始化后不需要调用内存分配函数。

    `mjModel` 由编译器构建。 `mjData` 在运行时根据 `mjModel` 构建。这种分离使得模拟多个模型以及每个模型的多个状态和控制变得容易，进而便于多线程采样和有限差分。顶层 API 函数反映了这种基本分离，格式如下：

    ```c++
    void mj_step(const mjModel* m, mjData* d);
    ```

* 交互式模拟和可视化

    原生 3D 可视化器提供网格和几何图元的渲染、纹理、反射、阴影、雾效、透明度、线框、天空盒、立体视觉（在支持四缓冲 OpenGL 的显卡上）。这些功能用于生成 3D 渲染，帮助用户深入了解物理模拟，包括自动生成的模型骨架、等效惯性盒、接触位置和法线、可分离为法向和切向分量的接触力、外部扰动力、局部坐标系、关节和驱动器轴以及文本标签等视觉辅助工具。可视化器需要具有 OpenGL 渲染上下文的通用窗口，从而允许用户采用自己选择的 GUI 库。随 MuJoCo 分发的代码示例 simulate.cc 展示了如何使用 GLFW 库实现这一点。相关的易用性功能是能够"伸入"模拟中，推动物体并观察物理响应。用户选择施加外部力和扭矩的物体，并实时查看扰动及其动态后果的渲染。这可用于视觉调试模型、测试反馈控制器的响应，或将模型配置为所需姿态。

* 强大而直观的建模语言

    MuJoCo 拥有自己的建模语言 MJCF。MJCF 的目标是提供对 MuJoCo 所有计算能力的访问，同时使用户能够快速开发新模型并进行实验。这一目标在很大程度上是通过一种类似于 HTML 内联 CSS 的广泛默认设置机制实现的。虽然 MJCF 有许多元素和属性，但用户在任何给定模型中只需设置少量参数。这使 MJCF 文件比许多其他格式更简短、更易读。

* 复合柔性对象的自动生成

    MuJoCo 的软约束可用于建模绳索、布料和可变形 3D 对象。这需要大量常规物体、关节、肌腱和约束协同工作。建模语言具有高级宏，模型编译器会自动将其展开为必要的标准模型元素集合。重要的是，这些生成的柔性对象能够与模拟的其余部分完全交互。

## 模型实例

在 MuJoCo 中，有几种不同实体被称为"模型"。用户首先在 MJCF 或 URDF 格式的 XML 文件中定义模型。然后，软件可以在不同媒介（文件或内存）和不同描述级别（高级或低级）中创建同一模型的多个实例。如下表所示，所有组合都是可能的：

|	|高级描述|	低级描述|
|---|---|----|
|文件形式|	MJCF/URDF (XML)|	MJB (二进制)|
内存形式|	mjSpec (C 结构体)|	mjModel (C 结构体)|

### 示例

以下是 MuJoCo 的 MJCF 格式的一个简单模型。它定义了一个固定在世界中的平面，一个用于更好地照亮物体并投射阴影的光源，以及一个具有 6 个自由度的浮动盒子（这就是"free"关节的作用）。

```xml
<mujoco>
  <worldbody>
    <light diffuse=".5 .5 .5" pos="0 0 3" dir="0 0 -1"/>
    <geom type="plane" size="1 1 0.1" rgba=".9 0 0 1"/>
    <body pos="0 0 1">
      <joint type="free"/>
      <geom type="box" size=".1 .2 .3" rgba="0 .9 0 1"/>
    </body>
  </worldbody>
</mujoco>
```

内置的 OpenGL 可视化器将此模型渲染为：

![alt text](../../public/mujoco-1-1.png)

如果对此模型进行模拟，盒子将会落在地面上。以下是不包含渲染的基本被动动力学模拟代码。

```c++
#include "mujoco.h"
#include "stdio.h"

char error[1000];
mjModel* m;
mjData* d;

int main(void) {
  // load model from file and check for errors
  m = mj_loadXML("hello.xml", NULL, error, 1000);
  if (!m) {
    printf("%s\n", error);
    return 1;
  }

  // make data corresponding to model
  d = mj_makeData(m);

  // run simulation for 10 seconds
  while (d->time < 10)
    mj_step(m, d);

  // free model and data
  mj_deleteData(d);
  mj_deleteModel(m);

  return 0;
}
```

这从技术上讲是一个 C 文件，但它也是一个合法的 C++ 文件。实际上，MuJoCo API 同时兼容 C 和 C++。通常用户代码会用 C++ 编写，因为它更加方便，而且不会牺牲效率，因为计算瓶颈在于已经高度优化的模拟器部分。

函数 `mj_step` 是顶层函数，它将模拟状态推进一个时间步长。当然，这个例子只是一个被动动力学系统。当用户指定控制或施加力并开始与系统交互时，情况会变得更加有趣。

接下来我们提供一个更详细的例子，展示 MJCF 的几个特性。请看以下 `example.xml`：

```xml
<mujoco model="example">
  <default>
    <geom rgba=".8 .6 .4 1"/>
  </default>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2=".6 .8 1" width="256" height="256"/>
  </asset>

  <worldbody>
    <light pos="0 1 1" dir="0 -1 -1" diffuse="1 1 1"/>
    <body pos="0 0 1">
      <joint type="ball"/>
      <geom type="capsule" size="0.06" fromto="0 0 0  0 0 -.4"/>
      <body pos="0 0 -0.4">
        <joint axis="0 1 0"/>
        <joint axis="1 0 0"/>
        <geom type="capsule" size="0.04" fromto="0 0 0  .3 0 0"/>
        <body pos=".3 0 0">
          <joint axis="0 1 0"/>
          <joint axis="0 0 1"/>
          <geom pos=".1 0 0" size="0.1 0.08 0.02" type="ellipsoid"/>
          <site name="end1" pos="0.2 0 0" size="0.01"/>
        </body>
      </body>
    </body>

    <body pos="0.3 0 0.1">
      <joint type="free"/>
      <geom size="0.07 0.1" type="cylinder"/>
      <site name="end2" pos="0 0 0.1" size="0.01"/>
    </body>
  </worldbody>

  <tendon>
    <spatial limited="true" range="0 0.6" width="0.005">
      <site site="end1"/>
      <site site="end2"/>
    </spatial>
  </tendon>
</mujoco>
```

这个模型是一个 7 自由度的机械臂，"握持"着一根连接着圆柱体的绳索。绳索通过带有长度限制的肌腱实现。肩部有一个球关节，肘部和腕部各有一对铰链关节。圆柱体内的盒子表示一个自由"关节"。XML 中的外层 body 元素是必需的 worldbody。注意，在两个刚体之间使用多个关节不需要创建虚拟刚体。

MJCF 文件包含指定模型所需的最少信息。胶囊体通过空间中的线段定义——在这种情况下，只需要指定胶囊体的半径。刚体框架的位置和方向是从属于它们的几何体推断出来的。惯性特性是在均匀密度假设下从几何体形状推断出来的。两个站点（site）被命名是因为肌腱定义需要引用它们，但其他元素没有被命名。关节轴只为铰链关节定义，而不为球关节定义。碰撞规则是自动定义的。摩擦属性、重力、模拟时间步长等都设置为默认值。在顶部指定的默认几何体颜色适用于所有几何体。

除了将编译后的模型保存为二进制 MJB 格式外，我们还可以将其保存为 MJCF 或人类可读的文本格式；分别参见 example_saved.xml 和 example_saved.txt。XML 版本与原始版本相似，而文本版本包含 mjModel 中的所有信息。将文本版本与 XML 版本进行比较，可以发现模型编译器为我们完成了多少工作。

![](https://mujoco.readthedocs.io/en/stable/_static/example.mp4)

