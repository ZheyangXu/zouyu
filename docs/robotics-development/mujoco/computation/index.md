# 计算

## 简介

本章详细阐述了MuJoCo的数学和算法基础。对于熟悉广义坐标或关节坐标系统下建模与仿真的读者而言，整体框架相对标准，因此我们仅对这部分内容作简要概述。本章主要篇幅将专注于探讨我们如何处理接触及其他约束条件。这一方法源自我们的最新研究成果，是MuJoCo独有的技术特色，因此我们会着重说明其设计动机并进行详细解释。虽然本章中的部分技术理念属于首次提出且尚未在其他文献中被描述，读者仍可在下文引用的论文中找到更多相关信息。

## 软接触模型

机器人与人类主要通过物理接触与环境进行交互。随着物理建模在机器人学、机器学习、动画、虚拟现实、生物力学等领域的重要性日益提升，我们需要既物理准确又计算高效的接触动力学仿真模型。仿真模型的一个应用是在将估计和控制策略部署到物理系统之前对其进行评估。另一个应用是自动设计这些策略——通常通过在内循环中使用仿真的数值优化来实现。后者施加了一个额外约束：关于接触动力学的目标函数应当适合数值优化。MuJoCo的基础接触模型在这些方面以及其他相关维度上都具有优势。在接下来的章节中，我们将讨论其优势，同时阐明与线性互补性(LCP)族接触模型（事实上的标准模型）的区别。

### 物理真实性与软接触

我们接触模型的许多优势可追溯到一个事实：我们放弃了LCP定式核心的严格互补性约束。我们将此类模型称为凸模型。对于无摩擦接触，放弃显式互补性约束并不会带来差异，因为所得凸二次规划的Karush-Kuhn-Tucker（KKT）最优性条件等价于LCP。但对于有摩擦接触，两者存在差异。

如果将凸模型视为LCP的近似，合理的问题是这种近似有多好。然而，我们并不这样看待它。相反，我们将LCP模型和凸模型都视为对物理现实的不同近似，各有优缺点。放弃严格互补性并用成本函数替代的直接后果是互补性可能被违反——这意味着接触法线方向的力和速度可以同时为正，而摩擦力可能不是最大耗散的。相关现象是，启动滑动的唯一方式是在法线方向产生一些运动。这些影响在数值上很小但不理想。然而，这一缺点在实际应用中几乎无关紧要，因为它基于硬接触的假设。实际上，所有物理材料都允许一定程度的变形。这在机器人学中尤为重要，因为与环境接触的机器人部件通常被设计为柔软的。对于软接触，互补性必然被违反：当存在穿透且材料将接触物体推开时，法线力和速度都为正。此外，如果物体静止在软表面上并有一定穿透，当我们向侧面推动它时，我们预期它开始滑动时会稍微上升。因此，与LCP的偏差实际上在存在软接触时增加了物理真实性。

当然，并非所有软模型都是理想的；例如，弹簧-阻尼器模型虽然柔软但受不稳定性困扰。同时，不同材料具有不同特性，因此与硬接触模型不同，软模型必须具有足够丰富的参数化，才能适应多种感兴趣的系统。这反过来又促进了接触模型参数的系统辨识。

### 计算效率

带有摩擦接触的LCP模型对应于NP难优化问题。这催生了近似求解器的产业，但不幸的副作用是许多流行的物理引擎使用文档记录不完善的捷径，导致所得运动方程难以表征。公平地说，NP难性是关于最坏情况性能的陈述，并不意味着在实践中快速求解LCP是不可能的。尽管如此，凸优化确实具有公认的优势。在MuJoCo中，我们观察到对于典型的机器人模型，投影高斯-赛德尔方法（PGS）的10次扫描就能产生与全局最小值在实际应用中几乎无法区分的解。当然，有些问题在数值上更难求解，即使它们是凸的，对于此类问题，我们有更高阶收敛的共轭梯度求解器。

计算效率的需求因用例而异。如果我们仅需要实时仿真，现代计算机足够快，能够处理大多数感兴趣的机器人系统，即使使用效率较低的求解器。然而，在优化环境中，不存在"足够快"的仿真。如果目标函数及其导数计算得更快，这将转化为更大的搜索范围或训练集或样本量，进而提高性能。这就是为什么我们投入大量精力开发高效求解器的原因。

### 连续时间

人们可能认为任何物理系统的运动方程在连续时间中都应当被唯一确定。然而，摩擦接触存在问题，因为库仑摩擦模型在连续时间中并不完全定义（潘列韦悖论）。这使得离散时间近似和相关的速度步进方案非常流行。这些模型的连续时间极限很少被研究。对于单一接触，在对施加力的不一定现实的假设下，极限满足库仑摩擦模型的微分包含形式；而对于多个同时接触，根据连续时间极限的具体取法，可能存在多个解。这些困难可追溯到硬接触的假设。

摩擦接触的凸模型过去也依赖于离散时间近似，但这并非必要。本模型在连续时间中定义，以力和加速度表示。考虑到现实世界中时间是连续的，这更为自然。这也是控制文献中的首选表述，事实上，我们希望MuJoCo能吸引来自该领域的用户。连续时间表述的另一个优势是它们适合复杂的数值积分，无需承担离散时间变分积分器的计算开销（当惯性依赖于构型时，这些积分器必然是隐式的）。连续时间动力学在时间反向上也是明确定义的，这在某些优化算法中是必需的。

### 逆动力学与优化

逆动力学的目标是根据多关节系统的位置、速度和加速度恢复施加的力和接触力。在硬接触条件下，这种计算是不可能的。考虑在不移动的情况下推墙，除非我们考虑材料变形——此时我们需要软接触模型，否则接触力无法从运动学中恢复。使用弹簧-阻尼器接触模型时，逆动力学计算十分简单，因为在这种情况下，接触力仅是位置和速度的函数，不依赖于施加的力。但这也是为什么弹簧-阻尼器模型不理想的原因：忽略施加的力意味着在每个时间步都引入误差，使模拟器处于永久的误差修正模式，进而导致不稳定性。相比之下，现代接触求解器在计算接触力/冲量时会考虑施加的力（以及所有内部力）。但这使逆运算变得复杂。本接触模型具有唯一定义的逆运算。实际上，逆动力学比正向动力学更易计算，因为优化问题变为对角化并分解为关于单个接触的独立优化问题——这些可以解析求解。

逆动力学在系统辨识、估计和控制的优化算法中发挥关键作用。它们使得将位置序列（或其参数表示）作为被优化对象成为可能。速度和加速度通过对位置求导计算；逆动力学用于计算施加的力和接触力；最后构建一个可依赖于上述所有因素的目标函数。这被互换称为时空优化、谱方法或直接配置法。MuJoCo独特地适合在存在接触和其他约束的情况下促进此类计算。

## 通用框架

下表总结了我们使用的符号表示法。与约束相关的额外符号将在后文介绍。在可行的情况下，我们同时展示了与数学符号对应的主要数据结构 `mjModel` 和 `mjData` 的字段。

| 符号 | 大小 | 描述 | MuJoCo 字段 |
|------|------|------|-------------|
| $n_Q$ | - | 位置坐标数量 | mjModel.nq |
| $n_V$ | - | 自由度数量 | mjModel.nv |
| $n_C$ | - | 活动约束数量 | mjData.nefc |
| $q$ | $n_Q$ | 关节位置 | mjData.qpos |
| $v$ | $n_V$ | 关节速度 | mjData.qvel |
| $\tau$ | $n_V$ | 施加力：被动力、驱动力、外力 | mjData.qfrc_passive + mjData.qfrc_actuator + mjData.qfrc_applied |
| $c(q, v)$ | $n_V$ | 偏置力：科里奥利力、离心力、重力 | mjData.qfrc_bias |
| $M(q)$ | $n_V \times n_V$ | 关节空间惯性矩阵 | mjData.qM |
| $J(q)$ | $n_C \times n_V$ | 约束雅可比矩阵 | mjData.efc_J |
| $r(q)$ | $n_C$ | 约束残差 | mjData.efc_pos |
| $f(q, v, \tau)$ | $n_C$ | 约束力 | mjData.efc_force |

所有模型元素在编译时被枚举，并组装成上述系统级向量和矩阵。以我们先前的机械臂模型为例，该模型拥有$n_V=13$个自由度：球形关节占3个，4个铰链关节各占1个，以及自由浮动物体占6个。这些自由度在所有尺寸为$n_V$的系统级向量和矩阵中以相同顺序出现。可以通过索引操作获取与特定模型元素对应的数据，具体方法在概述章节的说明部分有所展示。尺寸为$n_C$的向量和矩阵略有不同，因为活动约束会在运行时发生变化。在这种情况下，仍然存在固定的枚举顺序（对应于模型元素在mjModel中的出现顺序），但任何非活动约束都会被省略。

使用四元数表示三维方向时，位置坐标数量$n_Q$大于自由度数量$n_V$。这种情况在模型包含球形关节或自由关节时出现（即在大多数模型中）。此时，$\dot{q}$不等于$v$，至少在通常意义上不相等。相反，我们需要考虑刚体方向群$SO(3)$——它在四维空间中具有单位球面的几何结构。速度存在于这个球面的三维切空间中。所有内部计算都会考虑这一点。对于自定义计算，MuJoCo提供了mj_differentiatePos函数，它"减去"两个维度为$n_Q$的位置向量，并返回一个维度为$n_V$的速度向量。MuJoCo还提供了多个与四元数相关的实用函数。

MuJoCo在连续时间中计算正向和逆向动力学。然后，正向动力学通过所选的数值积分器在指定的mjModel.opt.timestep上进行积分。连续时间中的一般运动方程为：

$$M\dot{v} + c = \tau + J^Tf$$

雅可比矩阵建立了关节坐标与约束坐标之间的关系。它将运动向量（速度和加速度）从关节坐标映射到约束坐标：关节速度$v$映射为约束坐标中的速度$Jv$。雅可比矩阵的转置则将力向量从约束坐标映射到关节坐标：约束力$f$映射为关节坐标中的力$J^Tf$。

关节空间惯性矩阵$M$始终可逆。因此，一旦约束力$f$确定，我们就可以完成正向和逆向动力学计算，如下所示：

$$
\begin{array}{l}
forward: & \dot{v} = M^{-1}(\tau + J^T f - c) \\
inverse: & \tau = M\dot{v} + c - J^Tf
\end{array}
$$

约束力的计算是最困难的部分，将在后文详述。但首先，我们通过总结如何计算上述直至约束雅可比矩阵的各项量来完成对一般框架的描述。

* 施加力$\tau$包括弹簧-阻尼器和流体动力学产生的被动力、驱动力，以及用户指定的附加力。
* 偏置力$c$包括科里奥利力、离心力和重力。它们的总和通过递归牛顿-欧拉（RNE）算法计算，其中加速度设为0。
* 关节空间惯性矩阵$M$通过复合刚体（CRB）算法计算。这个矩阵通常相当稀疏，我们使用专为运动学树设计的自定义格式将其表示为稀疏矩阵。
* 由于我们经常需要将向量乘以$M$的逆矩阵，我们以保留稀疏性的方式计算其$L^TDL$分解。当后续需要$M^{-1}x$形式的量时，通过稀疏回代法计算。

在进行以上任何计算之前，我们先应用正向运动学，计算所有空间物体的全局位置和方向以及关节轴。虽然通常建议在局部坐标中应用RNE和CRB算法，但在这里我们为在全局坐标中进行的碰撞检测做准备，因此RNE和CRB也在全局坐标中实现。尽管如此，为了提高浮点精度，我们将每个运动学子树的数据表示在以子树质心为中心的全局坐标系中（mjData中以c开头的字段）。本章末尾将给出仿真流程的详细总结。

### 执行器模型

MuJoCo提供了一套灵活的执行器模型系统。所有执行器均采用单输入单输出（SISO）结构。第$i$个执行器的输入是用户指定的标量控制信号$u_i$，输出则是标量力$p_i$，该力通过传动装置确定的力矩臂向量映射到关节坐标系中。执行器还可以具有自身动态特性的激活状态$w_i$。所有执行器的控制输入存储在mjData.ctrl中，力输出存储在mjData.actuator_force中，而激活状态（如有）则存储在mjData.act中。

执行器的这三个组成部分——传动装置、激活动态和力生成——共同决定了执行器的工作方式。用户可以独立设置这些组件以获得最大的灵活性，或使用执行器快捷方式来实例化常见的执行器类型。

#### 传动装置

每个执行器都有一个由传动类型及其参数定义的标量长度$l_i(q)$。其梯度$\nabla l_i$是一个$n_V$维的力矩臂向量，决定了标量执行器力到关节力的映射关系。传动特性由执行器所连接的MuJoCo对象确定；可能的连接对象类型包括关节(joint)、肌腱(tendon)、父级关节(jointinparent)、滑块曲柄机构(slider-crank)、位点(site)和刚体(body)。

关节和肌腱

> 关节(joint)和肌腱(tendon)传动类型按预期方式工作，对应于执行器对目标对象施加力或扭矩的情况。球形关节较为特殊，详情请参阅actuator/general/joint文档。

父级关节

> 父级关节(jointinparent)传动类型专用于球形关节和自由关节，其特点是旋转测量在父级框架而非子级框架中进行。

滑块曲柄机构

> 滑块曲柄机构(slider-crank)传动类型将线性力转换为扭矩，如活塞驱动的内燃机。系统中包含相关示例模型。虽然滑块曲柄机构也可以通过创建MuJoCo刚体并用平等约束耦合它们来显式建模，但这种方法既效率较低又稳定性较差。

刚体

> 刚体(body)传动类型对应于在属于刚体的接触点施加力，用于模拟真空抓取器和生物力学粘附附件。关于粘附的更多信息，请参阅粘附执行器文档。这类传动目标具有固定的零长度$l_i(q)=0$。

位点

> 位点(site)传动类型对应于在位点框架中施加笛卡尔力/扭矩。当未定义参考位点(refsite)时（见下文），这些目标具有固定的零长度$l_i(q)=0$，适用于模拟喷气装置和螺旋桨：即固定在位点框架中的力和扭矩。

如果位点传动使用可选的refsite属性定义，则力和扭矩将在参考位点的框架中施加，而非位点自身的框架中。当定义了参考位点时，执行器长度非零，对应于两个位点的姿态差异，投影到参考框架中的选定方向上。这一长度可通过位置执行器控制，从而实现笛卡尔末端执行器控制。更多详情请参阅refsite文档。

### 状态执行器

某些执行器，如气动和液压缸以及生物肌肉，具有一种称为"激活"的内部状态。这是一种真正的动态状态，超越了关节位置$q$和速度$v$的范畴。在模型中包含此类执行器将导致三阶动力学特性。我们用向量$w$表示执行器的激活状态。这些状态具有一阶动态特性：

$$\dot{w}_i(u_i, w_i, l_i, \dot{l}_i)$$

其具体形式由激活类型和相应的模型参数决定。需要注意的是，每个执行器都具有独立于其他执行器的标量动态特性。目前实现的激活类型包括：

$$
\begin{array}{l}
integrator: & \dot{\omega}_i = u_i \\
filter: & \dot{\omega}_i = \frac{u_i - \omega_i}{t} \\
filterexact: & \dot{\omega}_i = \frac{u_i - \omega_i}{t} \\
muscle: & \dot{\omega}_i = muscle(u_i, w_i, l_i, \dot{l}_i)
\end{array}
$$

其中$t$是存储在mjModel.actuator_dynprm中的执行器特定时间常数。此外，激活类型还可以是"user"，此时$w_i$由用户定义的回调函数mjcb_act_dyn计算。激活类型也可以是"none"，对应于没有激活状态的常规执行器。向量$w$的维度等于激活类型不为"none"的执行器数量。

对于精确滤波器(filterexact)激活动态，$\dot{w}$的欧拉积分被替换为解析积分：

$$
\begin{array}{l}
filter: & w_{i+1} = w_i + \frac{h(u_i - w_i)}{t} \\
filterexact：& w_{i+1} = w_i + (u_i - w_i)(1 - e^{-\frac{h}{t}})
\end{array}
$$

这两个表达式在$h \rightarrow 0$极限下收敛到相同的值。值得注意的是，欧拉积分的滤波器在$t < h$时会发散，而精确积分的滤波器对任何正值$t$都保持稳定。

提前激活(actearly)：

> 如果actearly属性设置为"true"，mjData.actuator_force将基于$w_{i+1}$（下一个激活状态）计算，从而减少$u$的变化到加速度影响之间的延迟，使其提前一个时间步（因此总体动力学为二阶而非三阶）。

### 力生成机制

每个执行器生成的标量力$p_i$是某种函数：

$$p_i(u_i, w_i, l_i, \dot{l}_i)$$

与激活动态类似，力生成机制也是执行器特有的，不能与模型中的其他执行器相互作用。目前，当存在激活状态时，力与激活状态呈仿射关系；否则，与控制信号呈仿射关系：

$$p_i = (aw_i\ or \ au_i) + b_0 + b_1l_i + b_2\dot{l}_i$$

其中$a$是执行器特定的增益参数，$b_0$、$b_1$、$b_2$是执行器特定的偏置参数，分别存储在mjModel.actuator_gainprm和mjModel.actuator_biasprm中。通过不同设置增益和偏置参数，可以模拟直接力控制以及位置和速度伺服控制——在这种情况下，控制/激活具有参考位置或速度的含义。用户还可以通过安装回调函数mjcb_act_gain和mjcb_act_bias并将增益和偏置类型设置为"user"来计算自定义增益和偏置项。值得注意的是，仿射力生成使得可以使用力矩臂矩阵的伪逆从逆动力学计算的施加力中推断控制/激活值。然而，现实世界中使用的一些执行器并非仿射的（尤其是那些内嵌低级控制器的执行器），因此我们正在考虑对上述模型进行扩展。

综合以上所述，所有执行器在广义坐标中贡献的净力为：

$$\sum_i \nabla l_i(q)p_i(u_i, w_i, l_i(q), \dot{l}_i(q, v))$$

该量存储在mjData.qfrc_actuator中。它与用户在关节或笛卡尔坐标中定义的任何力（分别存储在mjData.qfrc_applied和mjData.xfrc_applied中）一起，被添加到施加力向量$\tau$中。

### 被动力

被动力定义为仅依赖于位置和速度，而不依赖于正向动力学中的控制或逆向动力学中的加速度的力。因此，这些力是正向和逆向动力学计算的输入，且在两种情况下完全相同。它们存储在mjData.qfrc_passive中。MuJoCo计算的被动力在物理意义上也是被动的，即它们不会增加能量。然而，用户可以安装回调函数mjcb_passive并向mjData.qfrc_passive添加可能增加能量的力。只要这些用户定义的力仅依赖于位置和速度，就不会干扰MuJoCo的运行。

MuJoCo可以计算三类被动力：

1. **关节和肌腱中的弹簧-阻尼器**。详情请参见以下属性：
   - 关节：stiffness（刚度）、springref（弹簧参考位置）、damping（阻尼）、springdamper（弹簧阻尼器）
   - 肌腱：stiffness（刚度）、springlength（弹簧长度）、damping（阻尼）
2. **重力补偿力**。详情请参见body gravcomp（刚体重力补偿）属性。
3. **周围介质施加的流体力**。详情请参见"流体力"章节。

### 数值积分

MuJoCo在连续时间下计算正向和逆向动力学。正向动力学的最终结果是关节加速度 $a=\dot{v}$ 以及模型中存在的执行器激活状态 $\dot{w}$。这些用于将仿真时间从$t$推进到$t+h$，并更新状态变量$q, v, w$。

MuJoCo提供四种数值积分器，包括三种单步积分器和一种多步四阶龙格-库塔积分器。在详细介绍这些积分器之前，我们先对单步欧拉积分器进行概述：显式、半隐式和速度隐式欧拉法。虽然MuJoCo不支持显式欧拉法，但从教学角度来看它很有价值。显式欧拉法可表示为：

$$\begin{array}{ll}
\text{激活状态:} & w_{t+h} = w_t + h\dot{w}_t \\
\text{速度:} & v_{t+h} = v_t + ha_t & (2)\\
\text{位置:} & q_{t+h} = q_t + hv_t
\end{array}$$

需要注意的是，在存在四元数的情况下，$q_t+hv_t$操作比简单的加法更为复杂，因为$q$和$v$的维度不同。MuJoCo未实现显式欧拉法的原因是，以下称为半隐式欧拉法的公式在各方面都更为优越，且已成为物理仿真的标准方法：

$$\begin{array}{ll}
v_{t+h} &= v_t + ha_t \\
q_{t+h} &= q_t + hv_{t+h} & (3)
\end{array}$$

比较公式(2)和(3)，我们可以看到在半隐式欧拉法中，位置更新使用的是新计算的速度。而隐式欧拉法的表达式为：

$$\begin{array}{ll}
v_{t+h} &= v_t + ha_{t+h} \\
q_{t+h} &= q_t + hv_{t+h} & (4)
\end{array}$$

比较公式(3)和(4)，我们发现速度更新右侧的加速度 $a_{t+h}=\dot{v}_{t+h}$ 是在下一时间步评估的。虽然在不进行步进的情况下无法评估下一步加速度，但我们可以使用一阶泰勒展开来近似这个量，并采用牛顿法的单次迭代。当展开仅针对速度（而非位置）时，这种积分器被称为速度隐式欧拉法。这种方法在以下系统中特别有效：多关节摆、空间中翻滚的物体、具有升力和阻力的系统，以及肌腱和执行器中具有显著阻尼的系统。将加速度表示为速度的函数：$a_t=a(v_t)$，我们希望近似的速度更新为：

$$v_{t+h} = v_t + ha(v_{t+h})$$

这是一个关于未知向量$v_{t+h}$的非线性方程，可以在每个时间步通过$a(v_{t+h})$在$v_t$附近的一阶展开进行数值求解。回顾一下，正向动力学为：

$$\begin{array}{l} a(v) = M^{-1}(\tau(v) - c(v) + J^Tf(v)) & (5) \end{array}$$

因此我们定义导数：

$$\begin{array}{ll}
\frac{\partial a(v)}{\partial v} &= M^{-1}D \\
D &\equiv \frac{\partial}{\partial v}(\tau(v) - c(v) + J^Tf(v))
\end{array}$$

对应于牛顿法的速度更新如下。首先，我们将右侧展开到一阶：

$$\begin{array}{ll}
v_{t+h} &= v_t + ha(v_{t+h}) \\
&\approx v_t + h\left(a(v_t) + \frac{\partial a(v)}{\partial v} \cdot (v_{t+h} - v_t)\right) \\
&= v_t + ha(v_t) + hM^{-1}D \cdot (v_{t+h} - v_t)
\end{array}$$

对两边同时乘以$M$并重新排列，得到：

$$(M - hD)v_{t+h} = (M - hD)v_t + hMa(v_t)$$

解出$v_{t+h}$，我们获得速度隐式更新公式：

$$\begin{array}{ll}
v_{t+h} &= v_t + h\hat{M}^{-1}Ma(v_t) \\
\hat{M} &\equiv M - hD & (6)
\end{array}$$

### 积分器

MuJoCo支持四种积分器：三种单步积分器和一种多步四阶龙格-库塔积分器。MuJoCo的所有三种单步积分器都使用公式(6)进行更新，但$D$矩阵的定义不同，该矩阵始终通过解析方法计算。

半隐式带隐式关节阻尼法（Euler）

> 在这种方法中，$D$仅包含关节阻尼的导数。需要注意的是，在这种情况下$D$是对角矩阵，$\hat{M}$是对称矩阵，因此可以使用$L^TL$分解（Cholesky分解的一种变体）。这一分解存储在mjData.qLD中。如果模型没有关节阻尼或设置了eulerdamp禁用标志，隐式阻尼将被禁用，系统将使用半隐式更新公式(3)而非(6)，从而避免对$\hat{M}$进行额外的分解（之所以称为额外，是因为$M$已经为加速度更新(5)进行了分解）。

速度隐式法（implicit）

> 在这种方法中，$D$包含除约束力$J^Tf(v)$以外的所有力的导数。目前忽略了约束力的导数，因为虽然计算它们是可能的，但过程复杂，而数值测试表明包含它们并不会带来太多益处。不过，约束力的解析导数计划在未来版本中实现。此外，为了提高计算效率，我们限制$D$具有与$M$相同的稀疏模式。这一限制将排除连接不同运动学树分支上的刚体的肌腱中的阻尼。由于$D$不是对称矩阵，我们不能使用Cholesky分解，但因为$D$和$M$具有与运动学树拓扑结构相对应的相同稀疏模式，$\hat{M}$的逆序$LU$分解保证不会产生填充。这一分解存储在mjData.qLU中。

快速速度隐式法（implicitfast）

> 在这种方法中，$D$包含implicit方法中使用的所有力的导数，但不包括由RNE算法计算的向心力和科里奥利力$c(v)$。此外，它被对称化处理：$D←(D+D^T)/2$。排除RNE导数的一个原因是它们的计算成本最高。第二个原因是，这些力只有在复杂摆和旋转物体具有高旋转速度时才会快速变化，这些情况并不常见，而且已经可以由龙格-库塔积分器（见下文）很好地处理。由于RNE导数也是$D$非对称性的主要来源，通过排除它们并进行对称化处理，我们可以使用更快的$L^TL$分解而非$LU$分解。

四阶龙格-库塔法（RK4）

> 我们连续时间公式的一个优势是可以使用更高阶的积分器，如龙格-库塔法或多步法。目前实现的唯一此类积分器是固定步长四阶龙格-库塔方法，不过用户可以通过调用mj_forward并自行积分加速度来轻松实现其他积分器。我们观察到，对于能量守恒系统（示例），RK4在稳定性和精度方面都比单步方法有明显优势，即使时间步长减小了4倍（因此计算量相同）。在存在大的速度依赖力的情况下，如果所选单步方法对这些力进行隐式积分，单步方法可能比RK4具有显著更高的稳定性。

::: info 选择时间步长和积分器

时间步长

> 通过减小时间步长$h$可以提高所有积分器的精度和稳定性。当然，较小的时间步长也会减慢模拟速度。时间步长可能是用户可以调整的最重要的参数。如果它太大，模拟将变得不稳定；如果太小，将浪费CPU时间而没有显著提高精度。总是存在一个舒适的范围，使时间步长"恰到好处"，但这个范围取决于具体模型。

积分器

总结

> 推荐使用 `implicitfast` 积分器，它通常具有稳定性和性能的最佳平衡。

**Euler**：

> 使用 Euler 可与旧模型和 MJX 兼容。特别是对于 MJX，设置 `eulerdamp` 禁用标志可以提高性能。

**implicitfast**：

> `implicitfast` 积分器的计算成本与Euler相似，但提供了更高的稳定性，因此是一个明显的改进。这是大多数模型推荐使用的积分器。

**implicit**：

> 相比 `implicitfast` 的优势在于对科里奥利力和向心力（包括陀螺力）的隐式积分。隐式积分这些力带来明显改进的最常见情况是当具有非对称惯性的自由物体快速旋转时。[ `gyroscopic.xml` ](https://mujoco.readthedocs.io/en/stable/_static/gyroscopic.xml) 展示了一个在斜面上滚动的椭球体，使用implicitfast时快速发散，但在implicit下保持稳定。

**RK4**：

> 这种积分器最适合能量守恒或接近能量守恒的系统。[ `pendulum.xml` ](https://mujoco.readthedocs.io/en/stable/_static/pendulum.xml) 展示了一个复杂的摆机构，使用Euler或implicitfast时快速发散，但在RK4下能很好地保持能量守恒。值得注意的是，在implicit下，这个模型不会发散，但会损失能量。

:::

### 状态

为完整描述一般框架，我们现在将讨论状态的概念。MuJoCo拥有一个紧凑、明确定义的内部状态，结合其确定性的计算流程，使得诸如重置状态和计算动力学导数等操作也同样明确定义。

状态完全封装在 `mjData` 结构体中，由几个组件构成。这些组件在 `mjtState` 中以位标志形式枚举，同时还包含几种常见组合，对应于下面的分组。可以使用 `mj_getState` 和 `mj_setState` 函数方便地从 `mjData` 读取和写入串联状态向量。

#### 物理状态

物理状态（ `mjSTATE_PHYSICS` ）包含在步进过程中进行时间积分的主要量。这些是mjData.{qpos, qvel, act}：

* **位置：qpos**  
  
  > 广义坐标中的构型，上文表示为 $q$。

* **速度：qvel**  
  > 广义速度，上文表示为 $v$。

* **执行器激活：act**  
  > `mjData.act` 包含有状态执行器的内部状态，上文表示为 $w$。

#### 完整物理状态

完整物理状态（ `mjSTATE_FULLPHYSICS` ）包含物理状态和两个额外组件：

* **时间：time**  
  
  > 仿真时间由标量 `mjData.time` 给出。由于物理学是时间不变的，它被排除在物理状态之外；例外情况包括时间依赖的用户回调和插件（例如，开环控制器），在这种情况下应包含时间。

* **插件状态：plugin_state**  
  
  > `mjData.plugin_state` 是由引擎插件声明的状态。更多详情请参阅插件状态部分。

#### 用户输入

这些输入字段（ `mjSTATE_USER` ）由用户设置并影响物理仿真，但仿真器不会修改它们。除 MoCap 姿态外，所有输入字段默认值为 0。

* **控制：ctrl**  
  
  > 控制由 XML 的执行器部分定义。 `mjData.ctrl` 值要么直接产生广义力（无状态执行器），要么影响 `mjData.act` 中的执行器激活，然后产生力。

* **辅助控制：qfrc_applied和xfrc_applied**  
  
  > `mjData.qfrc_applied` 是直接施加的广义力。  
  > `mjData.xfrc_applied` 是施加到各个刚体质心的笛卡尔力矩。例如，本地查看器使用此字段应用鼠标扰动。  
  > 注意， `qfrc_applied` 和 `xfrc_applied` 的效果通常可以通过适当的执行器定义重现。

* **MoCap姿态：mocap_pos和mocap_quat**  
  > `mjData.mocap_pos` 和 `mjData.mocap_quat` 是这里描述的特殊可选运动学状态，允许用户实时设置静态刚体的位置和方向，例如从动作捕捉设备流式传输6D姿态时。 `mj_resetData` 设置的默认值是刚体在默认构型下的姿态。

* **等式约束开关：eq_active**  
  
  > `mjData.eq_active` 是一个字节值数组，允许用户在运行时切换等式约束的状态。该数组的初始值是 `mjModel.eq_active0` ，可以在XML中使用等式约束的active属性设置。

* **用户数据：userdata**  
  
  > `mjData.userdata` 充当引擎不会修改的用户定义内存空间。例如，它可以被回调函数使用。这在编程章节中有更详细的描述。

#### 预热加速度

* **qacc_warmstart**  
  
  > `mjData.qacc_warmstart` 是用于预热约束求解器的加速度，保存自上一步。当使用像PGS这样收敛缓慢的约束求解器时，这些可以通过减少收敛所需的迭代次数来加速仿真。然而，请注意默认的牛顿求解器收敛速度非常快（通常2-3次迭代），以至于预热通常对速度没有影响，可以禁用。

不同的预热对动力学没有明显影响，但如果需要在加载非初始状态时实现完美的数值重现性，应该保存预热值。请注意，尽管它们对物理的影响可以忽略不计，但许多物理系统在时间步进时会以指数方式累积微小差异，迅速导致不同预热的轨迹发生偏离。

#### 积分状态

积分状态（ `mjSTATE_INTEGRATION` ）是以上所有 `mjData` 字段的并集，构成了正向动力学的全部输入集。在逆向动力学的情况下， `mjData.qacc` 也被视为输入变量。所有其他 `mjData` 字段都是积分状态的函数。

请注意，由 `mjSTATE_INTEGRATION` 给出的完整积分状态是最大主义的，包括了经常未使用的字段。如果需要较小的状态大小，避免保存未使用的字段可能是明智的。特别是xfrc_applied可能相当大（6 x nbody），但却经常未被使用。

#### 仿真状态： `mjData`

仿真状态是整个 `mjData` 结构体及其关联的内存缓冲区。此状态包括在动力学计算过程中计算的所有导出量。因为 `mjData` 缓冲区是为最坏情况预先分配的，所以从积分状态重新计算导出量通常比使用 `mj_copyData` 快得多。

## 约束模型

MuJoCo拥有一套极为灵活的约束模型，这些约束能够被后文所述的求解器以统一方式处理。在此，我们将从概念上解释各类约束的性质，以及它们如何在维度为$n_C$的系统级向量和矩阵中排列。每个概念性约束可以向总数$n_C$贡献一个或多个标量约束，而每个标量约束在约束雅可比矩阵$J$中对应一行。活动约束按类型排序，顺序与下文描述的类型顺序一致，然后在每种类型内按模型元素排序。约束类型包括：等式约束、摩擦损耗、限制、接触。限制在求解器内部被视为无摩擦接触处理，而非单独类型。我们在mjData中使用前缀efc来表示包含约束相关数据的系统级向量和矩阵。

### 等式约束

MuJoCo可以模拟一般形式为$r(q)=0$的等式约束，其中$r$可以是位置向量$q$的任何可微分标量或向量函数。它具有残差的语义。求解器实际上也能处理非完整约束，但目前尚未定义此类约束类型。每个等式约束向总约束数$n_C$贡献$\text{dim}(r)$个元素。$J$中的相应块就是残差的雅可比矩阵，即$\partial r/\partial q$。需要注意的是，由于四元数的特性，关于$q$的微分产生的向量大小为$n_V$而非$n_Q$。

除其他应用外，等式约束可用于创建"闭环关节"，即无法通过运动学树建模的关节。游戏引擎通常以这种方式表示所有关节。虽然MuJoCo中也可以这样做，但不推荐——因为这会导致模拟速度更慢且精度更低，实际上将MuJoCo变成了游戏引擎。唯一需要用等式约束表示关节的理由是模拟软关节——这可以通过约束求解器实现，但无法通过运动学树实现。

以下是五种等式约束类型。标题中的数字对应于每种情况下约束残差的维度。

connect: 3

> 此约束在一个点上连接两个刚体，有效地在运动学树外创建一个球形关节。模型指定要连接的两个刚体，以及每个刚体局部坐标系中的一个点（或"锚点"）。约束残差定义为这些点的全局三维位置之间的差异。注意，为同一对刚体指定两个连接约束可用于在运动学树外建模铰链关节。指定三个或更多连接约束（其锚点不共线）在数学上等同于焊接约束，但计算效率较低。

weld: 6

> 此约束将两个刚体焊接在一起，抑制它们之间所有相对自由度。由约束求解器强制执行的相对刚体位置和方向是mjModel中的参数。编译器从模型定义的初始配置（即mjModel.qpos0）中计算它们，但用户可以稍后更改它们。这个6D残差包含一个与连接约束相同的3D位置分量，后跟一个3D方向分量。后者定义为$\sin(\theta/2)(x, y, z)$，其中$\theta$是弧度表示的旋转角，$(x, y, z)$是对应于旋转轴的单位向量。对于小角度，这接近于方向差的指数映射表示（模2因子）。对于大角度，它避免了如果使用$\theta$而非$\sin(\theta/2)$会导致的环绕不连续性。然而它确实有一个缺点：当角度接近180度时，约束变弱。还要注意，如果一个刚体是另一个刚体的子级，实现焊接约束的更快且更准确的方法是简单地移除子级刚体中定义的所有关节。

joint: 1

> 此约束仅适用于标量关节：铰链和滑动关节。它可用于将一个关节锁定在恒定位置，或通过四次多项式耦合两个关节。锁定关节最好通过移除关节实现，但在特殊情况下很有用，如模拟间隙（通过软等式约束）。两个关节的耦合对于模拟螺旋关节或其他形式的机械耦合很有用。四次多项式模型定义如下。假设$y$是第一个关节的位置，$x$是第二个关节的位置，下标0表示模型初始配置mjModel.qpos0中的相应关节位置。那么等式约束为：

$$y-y_0=a_0+a_1(x-x_0)+a_2(x-x_0)^2+a_3(x-x_0)^3+a_4(x-x_0)^4$$

其中$a_0, \ldots, a_4$是模型中定义的系数。如果约束仅涉及一个关节，则简化为$y-y_0=a_0$。

tendon: 1

> 此约束与上述关节约束非常相似，但适用于肌腱长度而非关节位置。肌腱是依赖于位置向量的长度量。这种依赖关系可以是标量关节位置的线性组合，或绕空间障碍物的最小长度弦。与关节不同，关节位置在模型配置mjModel.qpos0中可以直接从位置向量读取，而肌腱长度的计算则不那么简单。这就是为什么所有肌腱的"静止长度"都由编译器计算并存储在mjModel中的原因。一般来说，所有名称以0结尾的mjModel字段都是编译器在初始模型配置mjModel.qpos0中计算的量。

distance: 1

::: warning Attention
注意

距离等式约束已在MuJoCo版本2.2.2中移除。如果您使用的是早期版本，请切换到相应版本的文档。
:::

### 摩擦损耗

摩擦损耗也称为干摩擦、静摩擦或负载独立摩擦（与随法向力变化的库仑摩擦相对）。与阻尼或粘性类似，它具有阻碍运动的效果。然而，它在运动开始之前就预先发挥作用，因此不能被建模为速度依赖型力。相反，它被建模为一种约束，即摩擦可以产生的力的绝对值的上限。这一上限通过相应模型元素的frictionloss属性指定，可应用于关节和肌腱。

摩擦损耗与所有其他约束类型的不同之处在于，它没有可关联的位置残差；因此我们形式上将$r(q)$的相应分量设为零。事实上，我们稍后将看到，我们的约束求解器公式需要以一种不寻常的方式扩展以纳入这种约束。尽管如此，受影响的关节或肌腱的速度充当速度"残差"——因为约束的效果是减小这一速度并理想情况下保持为零。因此，约束雅可比矩阵中的相应块仅仅是关节位置（或肌腱长度）关于$q$的雅可比矩阵。对于标量关节，这是一个在关节地址处为1、其余位置为0的向量。对于肌腱，这被称为力矩臂向量。

joint: 1, 3, 6

> 摩擦损耗不仅可以为标量关节（滑动和铰链）定义，还可以为具有3个自由度的球形关节和具有6个自由度的自由关节定义。一旦定义，它会独立应用于受影响关节的所有自由度。frictionloss参数具有与关节（线性或角度）兼容的隐含单位。自由关节是一个例外，因为它们同时具有线性和角度分量，而MJCF模型格式每个关节只允许一个frictionloss参数。在这种情况下，线性和角度分量使用相同的参数。有人可能会认为不应允许自由关节中的摩擦损耗。然而，我们允许它是因为它可以模拟有用的非物理效果，例如保持物体在原位直到某物以足够的力推动它。

tendon: 1

> 肌腱是标量量，因此为肌腱定义摩擦损耗总是增加一个标量约束。对于空间肌腱，这可用于模拟肌腱与其环绕的表面之间的摩擦。不过，这种摩擦将是负载独立的。要构建这种现象的更详细模型，可以创建几个小的浮动球体并用串联的肌腱连接它们。然后，球体与周围表面之间的接触将具有负载依赖（即库仑）摩擦，但这种模拟效率较低。

### 限制

限制和接触都有明确定义的空间残差，但与等式约束不同，它们是单侧的，即它们引入不等式而非等式约束。可以为关节和肌腱定义限制。这通过将相应的模型元素标记为"limited"并定义其"range"参数来完成。残差$r(q)$是当前位置/长度与range中指定的两个限制值中较近者之间的距离。这个距离的符号会自动调整，使得在未达到限制时为正，在限制处为零，在违反限制时为负。当这个距离小于"margin"参数时，约束变为活动状态。然而，这与将限制偏移margin并将margin设为0不同。相反，约束力通过后文描述的求解器参数依赖于距离。

对于给定的关节或肌腱，下限和上限可能同时变为活动状态。在这种情况下，它们都被包含在标量约束列表中，但应避免这种情况——通过增加范围或减小边界值。特别是，避免使用窄范围来近似等式约束。相反，使用显式等式约束，如果需要一些松弛度，可以通过调整求解器参数使约束变软。这在计算上更有效，不仅因为它涉及一个标量约束而非两个，而且因为求解等式约束力通常更快。

joint: 1, 2

> 限制可以为标量关节（铰链和滑动）以及球形关节定义。标量关节如上所述处理。球形关节限制应用于关节四元数的指数映射或角轴表示，即向量$(θx, θy, θz)$，其中$θ$是旋转角，$(x, y, z)$是对应于旋转轴的单位向量。限制应用于旋转角$θ$的绝对值。在运行时，限制由两个range参数中较大的一个确定。然而，为了语义清晰，应使用第二个range参数指定限制，并将第一个range参数设为0。编译器会强制执行这一规则。

tendon: 1, 2

> 肌腱是标量量，其限制如上所述处理。请注意，固定肌腱（标量关节位置的线性组合）可以有正负"长度"，因为关节位置是相对于关节参考定义的，可以为正也可以为负。然而，空间肌腱具有真实长度，不能为负。在设置肌腱限制的范围和边界值时请记住这一点。

### 接触

接触是最复杂的约束类型，无论是在模型中指定它们还是在需要执行的计算方面。这是因为接触建模本身就具有挑战性，此外，我们支持允许切向、扭转和滚动摩擦的通用接触模型，以及椭圆和金字塔摩擦锥。

MuJoCo使用点接触，在几何上由两个几何体之间的一个点和以该点为中心的空间坐标系定义，两者都以全局坐标表示。该坐标系的第一个（$x$）轴是接触法线方向，而其余（$y$和$z$）轴定义切平面。人们可能期望法线对应于$z$轴，如MuJoCo的可视化约定，但我们支持仅使用法线轴的无摩擦接触，这就是为什么我们希望将法线放在第一位置。与限制类似，当两个几何体分离时接触距离为正，当它们接触时为零，当它们穿透时为负。沿法线轴，接触点位于两个表面之间的中间位置（对于网格碰撞，这可能是近似的）。碰撞检测是一个单独的主题，将在下文详细讨论。我们现在需要的只是碰撞检测器提供的接触点、空间坐标系和法线距离。

除了上述在线计算的量外，每个接触还具有从模型定义中获得的几个参数。

| 参数 | 描述 |
|------|------|
| condim | 接触坐标系中接触力/扭矩的维度。<br>可以是1、3、4或6。 |
| friction | 摩擦系数向量，其维度为condim-1。具体系数的含义见下文。 |
| margin | 用于确定接触是否应被纳入全局接触数组mjData.contact的距离边界值。 |
| gap | 对于自定义计算，有时需要将接触包含在mjData.contact中但不生成接触力。这就是gap的作用：仅当法线距离小于(margin - gap)时才生成接触力。 |
| solref/solimp | 求解器参数，将在后文解释。 |

接触摩擦锥可以是椭圆形或金字塔形。这是由约束求解器的选择决定的全局设置：椭圆求解器使用椭圆锥，而金字塔求解器使用金字塔锥，将在后文中定义。condim参数决定接触类型，具有以下含义：

condim = 1（椭圆形为1，金字塔形为1）  

> 这对应无摩擦接触，仅添加一个标量约束。回顾一下，接触坐标系的第一个轴是接触法线。无摩擦接触只能沿法线方向产生力。这与关节或肌腱限制非常相似，但应用于两个几何体之间的距离。

condim = 3（椭圆形为3，金字塔形为4）  

> 这是常规摩擦接触，可以产生法向力以及阻止滑动的切向摩擦力。对这个数值的一种解释是在重力作用下平坦物体开始滑动的表面斜率。

condim = 4（椭圆形为4，金字塔形为6）  

> 除了法向力和切向力外，这种接触还可以产生阻止围绕接触法线旋转的扭转摩擦力矩，对应于接触表面片产生的力矩。这对模拟软指尖非常有用，能显著提高模拟抓取的稳定性。扭转摩擦系数的单位是长度，可解释为表面接触片的直径。

condim = 6（椭圆形为6，金字塔形为10）  

> 这种接触可以阻止两个几何体之间所有相对自由度的运动。特别是它增加了滚动摩擦，例如可用于防止球在平面上无限滚动。现实世界中的滚动摩擦源于接触点附近局部变形所消耗的能量。它可用于模拟轮胎和道路间的滚动摩擦，以及普遍地稳定接触。滚动摩擦系数也具有长度单位，可解释为能量消散的局部变形深度。

需要注意，condim不能为2或5。这是因为两个切向方向和两个滚动方向被视为成对处理。然而，一对内的摩擦系数可以不同，这可用于模拟如滑冰等现象。

现在我们更正式地描述摩擦锥及其对应的雅可比矩阵。仅在本节中，让$f$表示单个接触的约束力向量（而非系统级约束力向量），$\mu$表示摩擦系数向量，$n$表示接触维度condim。对于$n>1$，椭圆形和金字塔形摩擦锥定义为：

$$\begin{array}{l} \text{椭圆锥: } & K = \{f \in \mathbb{R}^n : f_1 \geq 0, f_1^2 \geq \sum_{i=2}^n f_i^2/\mu_{i-1}^2\} \end{array}$$

$$\begin{array}{l} \text{金字塔锥: } & K = \{f \in \mathbb{R}^{2(n-1)} : f \geq 0\} \end{array}$$

金字塔锥定义中的向量不等式是按元素理解的。对于$n=1$，两种锥体都定义为非负射线（这是锥体的一种特殊情况）。请注意，下文求解器部分讨论的系统级摩擦锥也将表示为$K$，它是这里定义的各个接触摩擦锥的乘积。

我们还需要指定约束力如何作用于系统。这是通过将一个六维基向量与$f$的每个分量相关联来实现的。基向量是空间向量：3D力后跟3D扭矩。将基向量排列为矩阵$E$的列，约束力在接触坐标系中产生的力/扭矩为$Ef$。基向量矩阵构建如下。

![](https://mujoco.readthedocs.io/en/stable/_images/contact_frame.svg)

该图说明了对应于$n=6$情况的完整基集。否则，我们根据锥体类型仅使用前$n$或$2(n-1)$列。椭圆锥更易理解。由于矩阵$E$是单位矩阵，$f$的前三个分量是沿接触坐标系轴作用的力，而接下来的三个分量是围绕这些轴作用的扭矩。对于金字塔锥，基向量对应于金字塔的边。每个向量结合了法向力分量和摩擦力或摩擦扭矩分量。通过摩擦系数的缩放确保所有基向量都位于我们近似的椭圆摩擦锥内。这同样适用于这些向量的任何凸组合。

最后，我们指定如何计算接触雅可比矩阵。首先，我们构建$6$乘$n_V$矩阵$S$，它将关节速度$v$映射到接触坐标系中表示的空间速度$Sv$。这是通过将接触点视为属于一个或另一个几何体，计算其空间雅可比矩阵，并减去这两个雅可比矩阵以获得$S$来实现的。我们使用的约定是接触力从第一个几何体指向第二个几何体，因此第一个几何体的空间雅可比矩阵带负号。接触雅可比矩阵则为$E^TS$。与所有其他约束一样，该矩阵被插入系统级雅可比矩阵$J$中。

## 约束求解器

本节阐述约束力的计算方法。这一过程分为两个阶段。首先，约束力被定义为一个凸优化问题的唯一全局解。对于金字塔锥，这是一个二次规划问题；对于椭圆锥，则是一个锥规划问题。其次，采用下文描述的算法来求解这一优化问题。我们还将说明约束模型的参数及其如何影响最终的动力学特性。

优化问题的定义本身包含两个步骤。我们首先定义一个关于加速度$\dot{v}$的原始问题，其中约束力是隐式的。然后，我们将关于加速度的原始问题转换为其拉格朗日对偶问题。对偶问题是一个关于约束力的凸优化问题，这些约束力同时也是原始问题的拉格朗日乘子。在正向动力学中，必须对原始问题或对偶问题进行数值求解。而在逆向动力学中，问题变为对角化的，可以解析求解。

原始公式基于广义高斯最小约束原理。在其基本形式中，高斯原理指出，如果我们有无约束动力学$M\dot{v}=\tau$并施加加速度约束$J\dot{v}=a_{ref}$，则产生的加速度将是：

$$\dot{v} = \arg \min_x |x - M^{-1}\tau|M^2 \quad \text{subject to} \quad Jx = a{ref}$$

其中加权$L_2$范数是通常的$|x|_M^2 = x^TMx$。因此，约束导致与无约束加速度$M^{-1}\tau$的偏差最小，这里用于测量关节坐标中偏差的度量由惯性矩阵给出。众所周知，这一原理等同于约束运动的拉格朗日-达朗贝尔原理。在这里，我们将利用它建立一个丰富而有原则的软约束模型。这将通过同时推广高斯原理中的成本函数和约束来实现。

除了先前介绍的符号外，我们还将使用以下符号：

| 符号 | 大小 | 描述 |
|------|------|------|
| $z$ | $n_C$ | 约束变形量 |
| $\omega$ | $n_C$ | 约束变形速度 |
| $k$ | $n_C$ | 虚拟约束刚度系数 |
| $b$ | $n_C$ | 虚拟约束阻尼系数 |
| $d$ | $n_C$ | 约束阻抗 |
| $A(q)$ | $n_C \times n_C$ | 约束空间中的逆惯性矩阵 |
| $R(q)$ | $n_C \times n_C$ | 约束空间中的对角正则化矩阵 |
| $a_{ref}$ | $n_C$ | 约束空间中的参考加速度 |
| $a_0(q, v, \tau)$ | $n_C$ | 约束空间中的无约束加速度 |
| $a_1(q, v, \dot{v})$ | $n_C$ | 约束空间中的受约束加速度 |
| $K(q)$ | - | 所有接触摩擦锥的乘积 |
| $\eta$ | - | 摩擦损耗力的上界 |
| $\Omega(q)$ | - | 可允许约束力的凸集合 |
| $E, F, C$ | - | 等式约束、摩擦损耗约束和接触约束的索引集 |

索引集将用于引用向量和矩阵的部分。例如，$J_C$是雅可比矩阵的所有对应于接触约束的行组成的子矩阵。

### 原始问题

我们首先构建一个优化问题，其解产生受约束加速度$\dot{v}$，然后解释其含义及合理性。该问题为：

(7)
$$
\begin{array}{l}
(\dot{v}, \dot{\omega}) = \arg\min_{(x, y)} \|x - M^{-1}(\tau - c)\|_M^2 + \|y - a_{ref}\|_{R^{-1}}^{Huber(\eta)} & (7) \\
\text{subject to} \quad J_E x_E - y_E = 0, \quad J_F x_F - y_F = 0, \quad J_C x_C - y_C \in K^* \\
\end{array}
$$

这里的新元素是对角正则化矩阵$R > 0$，它使约束变得柔软，以及参考加速度$a_{ref}$，它稳定约束。后者在精神上类似于Baumgarte稳定化方法，但它不是直接添加约束力，而是修改产生约束力的优化问题。由于这个问题本身是受约束的，$a_{ref}$与$f$之间的关系通常是非线性的。$R$和$a_{ref}$的计算方法将在后文基于求解器参数进行说明。现在我们假设它们是已知的。

优化变量$x$表示加速度（如高斯原理中所示），而$y$是约束空间中的松弛变量，用于建模软约束。如果我们强制解达到$y = a_{ref}$（可通过取极限$R \to 0$实现），就会得到硬约束模型。MuJoCo不允许这种极限情况，但仍然可以构建在现象上表现为硬约束的模型。

符号$K^*$表示摩擦锥的对偶。这源于数学上的逆向工程：我们希望在对原始问题取对偶后恢复约束$f \in K$，而锥的对偶的对偶就是锥本身。前文定义的金字塔摩擦锥实际上是自对偶的，但椭圆锥则不是。

Huber"范数"基于稳健统计学中的Huber函数：在零附近是二次的，当参数的绝对值超过阈值（在此例中由摩擦损耗参数给出）时平滑过渡到线性函数。设置$\eta = \infty$会恢复二次范数；我们对所有非摩擦损耗引起的约束力采用这一约定。这是另一个逆向工程的例子：我们希望对摩擦损耗力施加区间约束，这很不简单，因为拉格朗日对偶通常会产生非负约束。事实证明，Huber函数恰好是在对偶中获得区间约束所需的函数。在没有摩擦损耗约束的情况下，两种范数都变为二次型。

现在我们将问题(7)与高斯原理更紧密地联系起来，并给松弛变量赋予物理意义。考虑一个增广动力学系统，其位置为 $(q, z)$，速度为 $(v, \omega)$。新的状态变量对应于变形动力学。类似于原始系统中$v$不同于$\dot{q}$，这里$\omega$不同于 $\dot{z}$，尽管原因不同。变形与非零位置残差相关。回顾一下，我们对等式约束、限制、金字塔摩擦锥的所有分量以及椭圆摩擦锥的法向分量有明确定义的位置残差。对于这些变形变量，我们有$\dot{z} = \omega$。但对于摩擦损耗和椭圆锥的摩擦分量，我们有$z = 0$而$\omega \neq 0$。这是因为即使在约束空间中可能有运动（约束力旨在阻止这种运动），但没有位置误差。增广动力学为：

$$
\begin{array}{l}
\tilde{q} = \begin{bmatrix} q \\ z \end{bmatrix}, & \tilde{v} = \begin{bmatrix} v \\ \omega \end{bmatrix}, & \tilde{c} = \begin{bmatrix} c \\ 0 \end{bmatrix}, \\
 \quad \tilde{\tau} = \begin{bmatrix} \tau \\ R^{-1}a_{ref} \end{bmatrix}, & \tilde{M} = \begin{bmatrix} M & 0 \\ 0 & R^{-1} \end{bmatrix}, & \tilde{J} = \begin{bmatrix} J & -I \end{bmatrix}
\end{array}
$$

将高斯原理应用于这个系统就得到了上面的原始优化问题，不过没有Huber范数。现在，运动方程(1)变为：

$$\tilde{M}\dot{\tilde{v}} + \tilde{c} = \tilde{\tau} + \tilde{J}^T f$$

展开所有带波浪符号的项，可得原始和变形动力学的显式形式：

$$M\dot{v} + c = \tau + J^T f$$
$$\dot{\omega} = a_{ref} - Rf$$

因此，$R$具有变形逆惯性的含义，而$a_{ref}$具有无力变形加速度的含义。

MuJoCo是否将这些变形变量作为系统状态的一部分，并将其动态特性与关节位置和速度一起积分？目前不是，尽管在未来提供这样的选项可能是值得的。回顾一下，我们将正则化器和参考加速度的函数依赖定义为$R(q)$和$a_{ref}(q, v)$。这使问题(7)仅依赖于$(q, v, \tau)$，因此原始动力学实际上不受变形动力学的影响。由于到目前为止我们开发的通用约束模型对$R$和$a_{ref}$的计算方式没有做任何假设，我们的选择是一致的，并提高了模拟器效率。尽管如此，考虑到这些量与变形动力学相关，将它们定义为$R(z)$和$a_{ref}(z, \omega)$并模拟整个增广系统可能更为自然。下面我们将阐明这种模拟的一些好处。

什么时候变形动力学能够准确"跟踪"原始动力学？可以验证，当约束力$f$等于下文参数部分定义的量$f_+$时，就会发生这种情况。然后，变形状态成为关节位置和速度的静态函数，即$z = r(q)$和$\omega = J(q)v$。但通常情况下并非如此。假设你将手指按入软材料，比材料恢复形状的速度更快地拉回手指，然后再次按压。你在第二次按压时感受到的接触力不仅取决于你的手指和物体的刚体位置，还取决于第一次按压时产生的材料变形。模拟上述增广动力学将捕捉这种现象，而MuJoCo中实现的模型则忽略了它，转而假设所有物体在下一次接触前恢复形状。摩擦维度中的滑动也存在类似的相关现象，同样被忽略了。

### 简化原始问题

前面定义的原始问题(7)以及我们后面将得到的对偶问题都是带约束的优化问题。对偶问题形式会更简单，但仍然是约束优化，在数值上比无约束优化效率低。事实证明，原始问题可以简化为关于加速度的无约束优化问题。如果给定(7)中的$x$，对$y$的最小化可以用闭式解决。这也消除了约束，因为$y$的解自动满足约束。这样我们就得到了一个关于$x$的无约束优化问题，可以用更高效的算法求解。

这种简化基于这样一个事实：对(7)中的$y$进行最小化实质上是在约束集上找最近点——这个约束集要么是平面要么是锥体，可以解析求解。代入结果，我们得到无约束问题：

$$
\begin{array}

    \dot{v} = \arg\min_x \|x - M^{-1}(\tau - c)\|_M^2 + s(Jx - a_{ref}) & (8)

\end{array}
$$

函数$s(\cdot)$扮演软约束惩罚的角色。可以证明它是凸的且一次连续可微的。在金字塔摩擦锥的情况下，它是二次样条。

简化公式的另一个吸引人的特点是可以轻松计算逆动力学。由于上述问题是无约束且凸的，唯一的全局最小值使梯度消失。这产生了等式：

$$M\dot{v} + c = \tau - J^T \nabla s(J\dot{v} - a_{ref})$$

这是存在软约束时的解析逆动力学。与运动方程(1)比较，我们看到约束力$f$由函数$s(\cdot)$的负梯度给出。对$\dot{v}$再次求导得到：

$$\frac{\partial \tau}{\partial \dot{v}} = M + J^T H[s]J$$

这是施加力关于加速度的解析导数。因此，我们看到函数$s(\cdot)$及其导数是MuJoCo物理模型的关键。

### 对偶问题

构建拉格朗日对偶的过程有些繁琐但已经确立。我们跳到结果。上述原始问题的拉格朗日对偶是：

$$
\begin{array}{l}
f = \arg\min_\lambda \frac{1}{2} \lambda^T (A + R) \lambda + \lambda^T (a_0 - a_{ref}) & (9) \\
\text{subject to} \quad \lambda \in \Omega
\end{array}
$$

其中约束空间中的逆惯性为：

$$A = JM^{-1}J^T$$

约束空间中的无约束加速度为：

$$a_0 = JM^{-1}(\tau - c) + \dot{J}v$$

约束集$\Omega$如下：$\lambda_E$是无约束的，因为它是原始问题中等式约束的拉格朗日乘子。对于摩擦损耗，我们有逐元素应用的盒约束$|\lambda_F| \leq \eta$。对于接触，我们有$\lambda_C \in K$。对于金字塔锥，这仅仅是$\lambda_C \geq 0$，而对于椭圆锥，它是二阶锥约束。虽然$A$只是对称半正定的，但$R$通过构造是对称正定的，因此上述二次成本是严格凸的。因此，对于金字塔摩擦锥，我们有一个凸的盒约束二次规划问题；对于椭圆摩擦锥，我们有盒约束和二阶锥约束的混合。求解此问题的算法将在后文描述。

如前所述，MuJoCo的约束模型具有唯一定义的逆动力学，我们已经在上面的简化公式中看到了一种推导方法。这里我们从对偶公式再次推导它。回想一下，在逆动力学中，我们可以获取$(q, v, \dot{v})$而非$(q, v, \tau)$，因此无约束加速度$a_0$是未知的。但我们可以计算受约束加速度：

$$a_1 = J\dot{v} + \dot{J}v$$

现在可以通过求解以下优化问题来计算逆动力学：

$$f = \arg\min_\lambda \frac{1}{2} \lambda^T R \lambda + \lambda^T (a_1 - a_{ref})$$
$$\text{subject to} \quad \lambda \in \Omega$$

通过比较这两个凸优化问题的KKT条件，可以验证当满足以下条件时，它们的解一致：

$$\begin{array}a_1 = a_0 + Af & (10) \end{array}$$

这个关键等式本质上是在约束空间中投影的牛顿第二定律。它是通过将运动方程(1)中的项$c$移到右侧，从左侧乘以$JM^{-1}$，在两边加上$\dot{J}v$，并代入上述$A, a_0, a_1$的定义得到的。在实际实现中，我们并不真正计算加速度项$\dot{J}v$。这是因为我们的优化问题依赖于约束空间加速度的差异，即使我们计算了这一项，它也会抵消。

注意，逆问题中的二次项由$R$而非$A+R$加权。这告诉我们两点。首先，在对应于硬约束的极限$R \to 0$中，逆不再定义，这是可以预期的。其次，更有用的是，逆问题是对角的，即它分解为关于各个约束力的独立优化问题。唯一剩余的耦合是由约束集$\Omega$引起的，但该集合也在前面讨论的概念约束上解耦。事实证明，所有这些独立的优化问题都可以解析求解。唯一非平凡的情况是椭圆摩擦锥模型；我们在上述引用的论文中展示了如何处理它。它需要$R$的对角值有特定的耦合，MuJoCo会自动强制执行这种耦合，以便为每个模型启用精确的解析逆。

一旦计算了正向动力学，逆动力学在计算上基本上是免费的。这是因为正向动力学需要进入逆问题的所有量，所以唯一的额外步骤是解析公式。这使得在MuJoCo中实现自动正确性检查成为可能。当mjModel.opt.enableflags中的fwdinv标志打开时，在每个时间步结束时自动比较正向和逆向动力学，并将差异记录在mjData.solver_fwdinv中。差异表明正向求解器（它是数值的，通常提前终止）收敛不良。当然，逆动力学本身也很有用，无需先计算正向动力学。
