# 计算

## 简介

本章详细阐述了MuJoCo的数学和算法基础。对于熟悉广义坐标或关节坐标系统下建模与仿真的读者而言，整体框架相对标准，因此我们仅对这部分内容作简要概述。本章主要篇幅将专注于探讨我们如何处理接触及其他约束条件。这一方法源自我们的最新研究成果，是MuJoCo独有的技术特色，因此我们会着重说明其设计动机并进行详细解释。虽然本章中的部分技术理念属于首次提出且尚未在其他文献中被描述，读者仍可在下文引用的论文中找到更多相关信息。

## 软接触模型

机器人与人类主要通过物理接触与环境进行交互。随着物理建模在机器人学、机器学习、动画、虚拟现实、生物力学等领域的重要性日益提升，我们需要既物理准确又计算高效的接触动力学仿真模型。仿真模型的一个应用是在将估计和控制策略部署到物理系统之前对其进行评估。另一个应用是自动设计这些策略——通常通过在内循环中使用仿真的数值优化来实现。后者施加了一个额外约束：关于接触动力学的目标函数应当适合数值优化。MuJoCo的基础接触模型在这些方面以及其他相关维度上都具有优势。在接下来的章节中，我们将讨论其优势，同时阐明与线性互补性(LCP)族接触模型（事实上的标准模型）的区别。

### 物理真实性与软接触

我们接触模型的许多优势可追溯到一个事实：我们放弃了LCP定式核心的严格互补性约束。我们将此类模型称为凸模型。对于无摩擦接触，放弃显式互补性约束并不会带来差异，因为所得凸二次规划的Karush-Kuhn-Tucker（KKT）最优性条件等价于LCP。但对于有摩擦接触，两者存在差异。

如果将凸模型视为LCP的近似，合理的问题是这种近似有多好。然而，我们并不这样看待它。相反，我们将LCP模型和凸模型都视为对物理现实的不同近似，各有优缺点。放弃严格互补性并用成本函数替代的直接后果是互补性可能被违反——这意味着接触法线方向的力和速度可以同时为正，而摩擦力可能不是最大耗散的。相关现象是，启动滑动的唯一方式是在法线方向产生一些运动。这些影响在数值上很小但不理想。然而，这一缺点在实际应用中几乎无关紧要，因为它基于硬接触的假设。实际上，所有物理材料都允许一定程度的变形。这在机器人学中尤为重要，因为与环境接触的机器人部件通常被设计为柔软的。对于软接触，互补性必然被违反：当存在穿透且材料将接触物体推开时，法线力和速度都为正。此外，如果物体静止在软表面上并有一定穿透，当我们向侧面推动它时，我们预期它开始滑动时会稍微上升。因此，与LCP的偏差实际上在存在软接触时增加了物理真实性。

当然，并非所有软模型都是理想的；例如，弹簧-阻尼器模型虽然柔软但受不稳定性困扰。同时，不同材料具有不同特性，因此与硬接触模型不同，软模型必须具有足够丰富的参数化，才能适应多种感兴趣的系统。这反过来又促进了接触模型参数的系统辨识。

### 计算效率

带有摩擦接触的LCP模型对应于NP难优化问题。这催生了近似求解器的产业，但不幸的副作用是许多流行的物理引擎使用文档记录不完善的捷径，导致所得运动方程难以表征。公平地说，NP难性是关于最坏情况性能的陈述，并不意味着在实践中快速求解LCP是不可能的。尽管如此，凸优化确实具有公认的优势。在MuJoCo中，我们观察到对于典型的机器人模型，投影高斯-赛德尔方法（PGS）的10次扫描就能产生与全局最小值在实际应用中几乎无法区分的解。当然，有些问题在数值上更难求解，即使它们是凸的，对于此类问题，我们有更高阶收敛的共轭梯度求解器。

计算效率的需求因用例而异。如果我们仅需要实时仿真，现代计算机足够快，能够处理大多数感兴趣的机器人系统，即使使用效率较低的求解器。然而，在优化环境中，不存在"足够快"的仿真。如果目标函数及其导数计算得更快，这将转化为更大的搜索范围或训练集或样本量，进而提高性能。这就是为什么我们投入大量精力开发高效求解器的原因。

### 连续时间

人们可能认为任何物理系统的运动方程在连续时间中都应当被唯一确定。然而，摩擦接触存在问题，因为库仑摩擦模型在连续时间中并不完全定义（潘列韦悖论）。这使得离散时间近似和相关的速度步进方案非常流行。这些模型的连续时间极限很少被研究。对于单一接触，在对施加力的不一定现实的假设下，极限满足库仑摩擦模型的微分包含形式；而对于多个同时接触，根据连续时间极限的具体取法，可能存在多个解。这些困难可追溯到硬接触的假设。

摩擦接触的凸模型过去也依赖于离散时间近似，但这并非必要。本模型在连续时间中定义，以力和加速度表示。考虑到现实世界中时间是连续的，这更为自然。这也是控制文献中的首选表述，事实上，我们希望MuJoCo能吸引来自该领域的用户。连续时间表述的另一个优势是它们适合复杂的数值积分，无需承担离散时间变分积分器的计算开销（当惯性依赖于构型时，这些积分器必然是隐式的）。连续时间动力学在时间反向上也是明确定义的，这在某些优化算法中是必需的。

### 逆动力学与优化

逆动力学的目标是根据多关节系统的位置、速度和加速度恢复施加的力和接触力。在硬接触条件下，这种计算是不可能的。考虑在不移动的情况下推墙，除非我们考虑材料变形——此时我们需要软接触模型，否则接触力无法从运动学中恢复。使用弹簧-阻尼器接触模型时，逆动力学计算十分简单，因为在这种情况下，接触力仅是位置和速度的函数，不依赖于施加的力。但这也是为什么弹簧-阻尼器模型不理想的原因：忽略施加的力意味着在每个时间步都引入误差，使模拟器处于永久的误差修正模式，进而导致不稳定性。相比之下，现代接触求解器在计算接触力/冲量时会考虑施加的力（以及所有内部力）。但这使逆运算变得复杂。本接触模型具有唯一定义的逆运算。实际上，逆动力学比正向动力学更易计算，因为优化问题变为对角化并分解为关于单个接触的独立优化问题——这些可以解析求解。

逆动力学在系统辨识、估计和控制的优化算法中发挥关键作用。它们使得将位置序列（或其参数表示）作为被优化对象成为可能。速度和加速度通过对位置求导计算；逆动力学用于计算施加的力和接触力；最后构建一个可依赖于上述所有因素的目标函数。这被互换称为时空优化、谱方法或直接配置法。MuJoCo独特地适合在存在接触和其他约束的情况下促进此类计算。

## 通用框架

下表总结了我们使用的符号表示法。与约束相关的额外符号将在后文介绍。在可行的情况下，我们同时展示了与数学符号对应的主要数据结构 `mjModel` 和 `mjData` 的字段。

| 符号 | 大小 | 描述 | MuJoCo 字段 |
|------|------|------|-------------|
| $n_Q$ | - | 位置坐标数量 | mjModel.nq |
| $n_V$ | - | 自由度数量 | mjModel.nv |
| $n_C$ | - | 活动约束数量 | mjData.nefc |
| $q$ | $n_Q$ | 关节位置 | mjData.qpos |
| $v$ | $n_V$ | 关节速度 | mjData.qvel |
| $\tau$ | $n_V$ | 施加力：被动力、驱动力、外力 | mjData.qfrc_passive + mjData.qfrc_actuator + mjData.qfrc_applied |
| $c(q, v)$ | $n_V$ | 偏置力：科里奥利力、离心力、重力 | mjData.qfrc_bias |
| $M(q)$ | $n_V \times n_V$ | 关节空间惯性矩阵 | mjData.qM |
| $J(q)$ | $n_C \times n_V$ | 约束雅可比矩阵 | mjData.efc_J |
| $r(q)$ | $n_C$ | 约束残差 | mjData.efc_pos |
| $f(q, v, \tau)$ | $n_C$ | 约束力 | mjData.efc_force |

所有模型元素在编译时被枚举，并组装成上述系统级向量和矩阵。以我们先前的机械臂模型为例，该模型拥有$n_V=13$个自由度：球形关节占3个，4个铰链关节各占1个，以及自由浮动物体占6个。这些自由度在所有尺寸为$n_V$的系统级向量和矩阵中以相同顺序出现。可以通过索引操作获取与特定模型元素对应的数据，具体方法在概述章节的说明部分有所展示。尺寸为$n_C$的向量和矩阵略有不同，因为活动约束会在运行时发生变化。在这种情况下，仍然存在固定的枚举顺序（对应于模型元素在mjModel中的出现顺序），但任何非活动约束都会被省略。

使用四元数表示三维方向时，位置坐标数量$n_Q$大于自由度数量$n_V$。这种情况在模型包含球形关节或自由关节时出现（即在大多数模型中）。此时，$\dot{q}$不等于$v$，至少在通常意义上不相等。相反，我们需要考虑刚体方向群$SO(3)$——它在四维空间中具有单位球面的几何结构。速度存在于这个球面的三维切空间中。所有内部计算都会考虑这一点。对于自定义计算，MuJoCo提供了mj_differentiatePos函数，它"减去"两个维度为$n_Q$的位置向量，并返回一个维度为$n_V$的速度向量。MuJoCo还提供了多个与四元数相关的实用函数。

MuJoCo在连续时间中计算正向和逆向动力学。然后，正向动力学通过所选的数值积分器在指定的mjModel.opt.timestep上进行积分。连续时间中的一般运动方程为：

$$M\dot{v} + c = \tau + J^Tf$$

雅可比矩阵建立了关节坐标与约束坐标之间的关系。它将运动向量（速度和加速度）从关节坐标映射到约束坐标：关节速度$v$映射为约束坐标中的速度$Jv$。雅可比矩阵的转置则将力向量从约束坐标映射到关节坐标：约束力$f$映射为关节坐标中的力$J^Tf$。

关节空间惯性矩阵$M$始终可逆。因此，一旦约束力$f$确定，我们就可以完成正向和逆向动力学计算，如下所示：

$$
\begin{array}{l}
forward: & \dot{v} = M^{-1}(\tau + J^T f - c) \\
inverse: & \tau = M\dot{v} + c - J^Tf
\end{array}
$$

约束力的计算是最困难的部分，将在后文详述。但首先，我们通过总结如何计算上述直至约束雅可比矩阵的各项量来完成对一般框架的描述。

* 施加力$\tau$包括弹簧-阻尼器和流体动力学产生的被动力、驱动力，以及用户指定的附加力。
* 偏置力$c$包括科里奥利力、离心力和重力。它们的总和通过递归牛顿-欧拉（RNE）算法计算，其中加速度设为0。
* 关节空间惯性矩阵$M$通过复合刚体（CRB）算法计算。这个矩阵通常相当稀疏，我们使用专为运动学树设计的自定义格式将其表示为稀疏矩阵。
* 由于我们经常需要将向量乘以$M$的逆矩阵，我们以保留稀疏性的方式计算其$L^TDL$分解。当后续需要$M^{-1}x$形式的量时，通过稀疏回代法计算。

在进行以上任何计算之前，我们先应用正向运动学，计算所有空间物体的全局位置和方向以及关节轴。虽然通常建议在局部坐标中应用RNE和CRB算法，但在这里我们为在全局坐标中进行的碰撞检测做准备，因此RNE和CRB也在全局坐标中实现。尽管如此，为了提高浮点精度，我们将每个运动学子树的数据表示在以子树质心为中心的全局坐标系中（mjData中以c开头的字段）。本章末尾将给出仿真流程的详细总结。

### 执行器模型

MuJoCo提供了一套灵活的执行器模型系统。所有执行器均采用单输入单输出（SISO）结构。第$i$个执行器的输入是用户指定的标量控制信号$u_i$，输出则是标量力$p_i$，该力通过传动装置确定的力矩臂向量映射到关节坐标系中。执行器还可以具有自身动态特性的激活状态$w_i$。所有执行器的控制输入存储在mjData.ctrl中，力输出存储在mjData.actuator_force中，而激活状态（如有）则存储在mjData.act中。

执行器的这三个组成部分——传动装置、激活动态和力生成——共同决定了执行器的工作方式。用户可以独立设置这些组件以获得最大的灵活性，或使用执行器快捷方式来实例化常见的执行器类型。

#### 传动装置

每个执行器都有一个由传动类型及其参数定义的标量长度$l_i(q)$。其梯度$\nabla l_i$是一个$n_V$维的力矩臂向量，决定了标量执行器力到关节力的映射关系。传动特性由执行器所连接的MuJoCo对象确定；可能的连接对象类型包括关节(joint)、肌腱(tendon)、父级关节(jointinparent)、滑块曲柄机构(slider-crank)、位点(site)和刚体(body)。

关节和肌腱

> 关节(joint)和肌腱(tendon)传动类型按预期方式工作，对应于执行器对目标对象施加力或扭矩的情况。球形关节较为特殊，详情请参阅actuator/general/joint文档。

父级关节

> 父级关节(jointinparent)传动类型专用于球形关节和自由关节，其特点是旋转测量在父级框架而非子级框架中进行。

滑块曲柄机构

> 滑块曲柄机构(slider-crank)传动类型将线性力转换为扭矩，如活塞驱动的内燃机。系统中包含相关示例模型。虽然滑块曲柄机构也可以通过创建MuJoCo刚体并用平等约束耦合它们来显式建模，但这种方法既效率较低又稳定性较差。

刚体

> 刚体(body)传动类型对应于在属于刚体的接触点施加力，用于模拟真空抓取器和生物力学粘附附件。关于粘附的更多信息，请参阅粘附执行器文档。这类传动目标具有固定的零长度$l_i(q)=0$。

位点

> 位点(site)传动类型对应于在位点框架中施加笛卡尔力/扭矩。当未定义参考位点(refsite)时（见下文），这些目标具有固定的零长度$l_i(q)=0$，适用于模拟喷气装置和螺旋桨：即固定在位点框架中的力和扭矩。

如果位点传动使用可选的refsite属性定义，则力和扭矩将在参考位点的框架中施加，而非位点自身的框架中。当定义了参考位点时，执行器长度非零，对应于两个位点的姿态差异，投影到参考框架中的选定方向上。这一长度可通过位置执行器控制，从而实现笛卡尔末端执行器控制。更多详情请参阅refsite文档。

### 状态执行器

某些执行器，如气动和液压缸以及生物肌肉，具有一种称为"激活"的内部状态。这是一种真正的动态状态，超越了关节位置$q$和速度$v$的范畴。在模型中包含此类执行器将导致三阶动力学特性。我们用向量$w$表示执行器的激活状态。这些状态具有一阶动态特性：

$$\dot{w}_i(u_i, w_i, l_i, \dot{l}_i)$$

其具体形式由激活类型和相应的模型参数决定。需要注意的是，每个执行器都具有独立于其他执行器的标量动态特性。目前实现的激活类型包括：

$$
\begin{array}{l}
integrator: & \dot{\omega}_i = u_i \\
filter: & \dot{\omega}_i = \frac{u_i - \omega_i}{t} \\
filterexact: & \dot{\omega}_i = \frac{u_i - \omega_i}{t} \\
muscle: & \dot{\omega}_i = muscle(u_i, w_i, l_i, \dot{l}_i)
\end{array}
$$

其中$t$是存储在mjModel.actuator_dynprm中的执行器特定时间常数。此外，激活类型还可以是"user"，此时$w_i$由用户定义的回调函数mjcb_act_dyn计算。激活类型也可以是"none"，对应于没有激活状态的常规执行器。向量$w$的维度等于激活类型不为"none"的执行器数量。

对于精确滤波器(filterexact)激活动态，$\dot{w}$的欧拉积分被替换为解析积分：

$$
\begin{array}{l}
filter: & w_{i+1} = w_i + \frac{h(u_i - w_i)}{t} \\
filterexact：& w_{i+1} = w_i + (u_i - w_i)(1 - e^{-\frac{h}{t}})
\end{array}
$$

这两个表达式在$h \rightarrow 0$极限下收敛到相同的值。值得注意的是，欧拉积分的滤波器在$t < h$时会发散，而精确积分的滤波器对任何正值$t$都保持稳定。

提前激活(actearly)： 

> 如果actearly属性设置为"true"，mjData.actuator_force将基于$w_{i+1}$（下一个激活状态）计算，从而减少$u$的变化到加速度影响之间的延迟，使其提前一个时间步（因此总体动力学为二阶而非三阶）。
