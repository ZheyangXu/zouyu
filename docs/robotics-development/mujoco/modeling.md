# 建模

## 简介

MuJoCo 可以加载其原生 MJCF 格式的 XML 模型文件，也支持更为流行但功能相对有限的 URDF 格式。本章节是 MJCF 建模指南。详细的参考手册可在"XML 参考"章节中查阅。关于 URDF 的文档可在其他地方找到；在此我们仅描述 MuJoCo 特有的 URDF 扩展。

MJCF 模型能够表示具有广泛特性和模型元素的复杂动力学系统。要访问所有这些功能，需要一种丰富的建模格式，如果在设计时不考虑易用性，这种格式可能会变得繁琐。因此，我们努力将 MJCF 设计为一种可扩展的格式，使用户可以从简单开始，随后构建更详细的模型。特别有帮助的是受到 HTML 内联 CSS（级联样式表）启发的广泛默认设置机制。这使用户能够快速创建新模型并进行实验。众多可用于重新配置仿真管道的选项，以及快速重新加载功能，进一步辅助了实验过程，使模型编辑成为一个交互式过程。

MJCF 可以被视为建模格式和编程语言的混合体。它内置了编译器，这通常是与编程语言相关的概念。虽然 MJCF 不具备通用编程语言的全部功能，但根据模型的设计方式，系统会自动调用许多复杂的编译时计算。

### 加载模型

正如"概述"章节中"模型实例"部分所解释的，MuJoCo 模型可以从 MJCF 或 URDF 格式的纯文本 XML 文件中加载，然后编译成底层的 mjModel。另外，之前保存的 mjModel 也可以直接从二进制 MJB 文件加载——虽然该文件格式未公开文档，但本质上是 mjModel 内存缓冲区的一个副本。MJCF 和 URDF 文件通过 [ `mj_loadXML` ](https://mujoco.readthedocs.io/en/stable/APIreference/APIfunctions.html#mj-loadxml) 函数加载，而 MJB 文件则通过 [ `mj_loadModel` ](https://mujoco.readthedocs.io/en/stable/APIreference/APIfunctions.html#mj-loadmodel) 函数加载。

当加载 XML 文件时，系统首先使用内部的 TinyXML 解析器将其解析为文档对象模型（DOM）。然后，这个 DOM 被处理并转换为高级 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec) 对象。这种转换取决于模型格式——格式是从 XML 文件的顶层元素推断出来的，而非从文件扩展名判断。需要注意的是，有效的 XML 文件必须有唯一的顶层元素。对于 MJCF 格式，这个元素必须是 mujoco；对于 URDF 格式，则必须是 robot。

### 编译模型

一旦创建了高级 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec)  对象——无论是通过加载 MJCF 文件、URDF 文件，还是以编程方式创建——它就会被编译成 [ `mjModel` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjmodel)。编译过程独立于加载过程，这意味着无论 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec)  是如何创建的，编译器的工作方式都是一样的。解析器和编译器都会进行全面的错误检查，并在遇到第一个错误时中止。产生的错误信息包含 XML 文件中的行号和列号，这些信息通常都很明确，因此我们在此不再赘述。解析器使用自定义模式来确保文件结构、元素和属性的有效性。随后，编译器会应用许多额外的语义检查。最后，系统会执行一步编译后模型的仿真，并拦截任何运行时错误。这是通过（临时）将 [ `mju_user_error` ](https://mujoco.readthedocs.io/en/stable/APIreference/APIglobals.html#mju-user-error) 设置为指向一个抛出 C++ 异常的函数来实现的；如有需要，用户可以在运行时实现类似的错误拦截功能。

整个解析和编译过程非常快速——如果模型不包含大型网格或需要通过仿真计算的执行器长度范围，整个过程通常不到一秒。这使得用户可以通过频繁重新加载和可视化更改来交互式地设计模型。值得注意的是，[ `simulate.cc` ](https://mujoco.readthedocs.io/en/stable/programming/samples.html#sasimulate) 代码示例中有一个重新加载当前模型的键盘快捷键（Ctrl+L）。

### 保存模型

一个 MJCF 模型可以由多个（包含的）XML 文件以及 XML 中引用的网格、高度场和纹理组成。编译后，所有这些文件的内容都会被整合到 mjModel 中，可以通过 [ `mj_saveModel` ](https://mujoco.readthedocs.io/en/stable/APIreference/APIfunctions.html#mj-savemodel) 函数将其保存为二进制 MJB 文件。MJB 是一个独立的文件，不引用任何其他文件，并且加载速度更快。因此，我们建议将常用模型保存为 MJB 格式，并在需要进行仿真时加载它们。

还可以使用 [ `mj_saveLastXML` ](https://mujoco.readthedocs.io/en/stable/APIreference/APIfunctions.html#mj-savelastxml) 函数将编译后的 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec)  保存为 MJCF 格式。如果对应的 mjModel 中的任何实值字段在编译后被修改（这种情况不常见，但在系统识别应用中可能发生），这些修改会在保存前自动复制回 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec) 。需要注意的是，无法在编译后的模型中进行结构性更改。XML 写入器会尝试生成最小的 MJCF 文件，该文件保证能够编译成相同的模型，只有因实值的纯文本表示而导致的微小数值差异。生成的文件结构可能与原始文件不同，因为 MJCF 有许多用户便利功能，允许以不同方式指定相同的模型。XML 写入器使用 MJCF 的"规范"子集，其中所有坐标都是局部的，所有刚体位置、方向和惯性属性都被明确指定。在"计算"章节中，我们展示了一个 MJCF 文件示例及其对应的保存结果。

### 编辑模型

从 MuJoCo 3.2 版本开始，可以使用 [ `mjSpec` ](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjspec)  结构体和相关 API 创建和修改模型。更多详细信息，请参阅"模型编辑"章节。

## 模型机理

MJCF 在模型创建过程中使用了几种跨越多个模型元素的机制。为避免重复，我们将在本节中详细描述这些机制。这些机制并不对应"计算"章节中介绍的新模拟概念，而是旨在简化 MJCF 模型的创建，并使用户能够使用不同的数据格式，而无需手动转换为标准格式。

### 运动学树(Kinematic Tree)

MJCF 文件的主要部分是由嵌套的 body 元素创建的 XML 树。顶层 body 比较特殊，称为 worldbody（世界刚体）。这种树状组织结构与 URDF 形成对比，在 URDF 中，用户创建一组链接，然后通过指定子链接和父链接的关节来连接它们。而在 MJCF 中，子刚体在 XML 的意义上就是父刚体的子元素。

当在刚体内定义关节时，其功能并非连接父子刚体，而是在它们之间创建运动自由度。如果某个刚体内没有定义关节，则该刚体会被焊接到其父刚体上。MJCF 中的一个刚体可以包含多个关节，因此不需要为创建复合关节而引入虚拟刚体。相反，只需在同一刚体内定义所有构成所需复合关节的基本关节即可。例如，两个滑块和一个铰链可以用来建模在平面内移动的刚体。

其他 MJCF 元素可以在由嵌套刚体元素创建的树中定义，特别是 joint（关节）、geom（几何体）、site（位点）、camera（相机）和 light（光源）。当元素在刚体内定义时，它就固定在该刚体的局部坐标系中，并始终随之移动。引用多个刚体或根本不引用刚体的元素则在运动学树外的独立部分中定义。

### 默认设置

MJCF 拥有一套完善的默认属性值设置机制。这使我们能够拥有大量元素和属性来展示软件的丰富功能，同时编写简短易读的模型文件。这种机制还使用户能够在一处进行更改，并使其在整个模型中传播。我们先来看一个例子。

```xml
<mujoco>
  <default class="main">
    <geom rgba="1 0 0 1"/>
    <default class="sub">
      <geom rgba="0 1 0 1"/>
    </default>
  </default>

  <worldbody>
    <geom type="box"/>
    <body childclass="sub">
      <geom type="ellipsoid"/>
      <geom type="sphere" rgba="0 0 1 1"/>
      <geom type="cylinder" class="main"/>
    </body>
  </worldbody>
</mujoco>
```

这个例子实际上无法编译，因为缺少一些必要信息，但在这里我们只关注几何体（geom）rgba 值的设置。由于默认设置机制，上面创建的四个几何体最终会具有以下 rgba 值：

|几何体类型|集合体 rgba|
|---|---|
|box|1 0 0 1|
|elipsoid|0 1 0 1|
|sphere|0 0 1 1|
|cylinder|1 0 0 1|

盒子（box）使用顶层默认类"main"来设置其未定义的属性，因为没有指定其他类。而 body 元素指定了 childclass 为"sub"，这导致该刚体的所有子元素（及其子元素的子元素等）都使用"sub"类，除非另有指定。因此椭球体（ellipsoid）使用"sub"类。球体（sphere）显式定义了 rgba 值，这会覆盖默认设置。圆柱体（cylinder）指定了默认类为"main"，所以它使用"main"而非"sub"，尽管后者是在包含该几何体的刚体的 childclass 属性中指定的。

现在我们来描述一般规则。MuJoCo 支持无限数量的默认类，这些类由 XML 中可能嵌套的 default 元素创建。每个类都有一个唯一的名称——这是必需的属性，除了顶层类，如果未定义，其名称为"main"。每个类还包含一整套虚拟模型元素，其属性设置如下。当一个默认类在另一个默认类内定义时，子类会自动继承父类的所有属性值。然后它可以通过定义相应的属性来覆盖部分或全部属性值。顶层默认类没有父类，因此其属性被初始化为内部默认值，这些值在"参考"章节中有所展示。

默认类中包含的虚拟元素不是模型的一部分；它们仅用于初始化实际模型元素的属性值。当首次创建一个实际元素时，其所有属性都从当前活动默认类中对应的虚拟元素复制而来。系统总是有一个活动的默认类，可以通过以下三种方式之一确定：如果当前元素或其任何祖先刚体都未指定类，则使用顶层类（无论它是叫"main"还是其他名称）。如果当前元素未指定类，但其一个或多个祖先刚体指定了 childclass，则使用最近祖先刚体的 childclass。如果当前元素指定了一个类，则使用该类，无论其祖先刚体中的任何 childclass 属性如何。

某些属性，如刚体惯性，可以处于特殊的未定义状态。这指示编译器从其他信息中推断相应的值，在这种情况下是从附加到刚体的几何体的惯性中推断。未定义状态无法在 XML 文件中输入。因此，一旦某个属性在给定类中被定义，它就不能在该类或其任何子类中被取消定义。所以，如果目标是在给定模型元素中保持某个属性未定义，那么它必须在活动默认类中也是未定义的。

最后一个特殊点是执行器（actuators）。它们不同是因为一些与执行器相关的元素实际上是快捷方式，而快捷方式与默认设置机制的交互方式并不那么直观。这将在下面的"执行器快捷方式"部分中解释。

## 坐标系

在运动学树中定义的所有元素的位置和方向都是以局部坐标表示的，刚体相对于其父刚体，而几何体、关节、位点、相机和光源则相对于包含它们的刚体。

与此相关的属性是 compiler/angle。它指定 MJCF 文件中的角度是以度还是弧度表示（编译后，角度始终以弧度表示）。

位置通过以下方式指定：

> pos: real(3), "0 0 0" 相对于父级的位置。

### 坐标系方向

几个模型元素都有与之关联的右手空间框架。这些都是在运动学树中定义的元素，除了关节之外。空间框架由其位置和方向定义。指定三维位置很直观，但指定三维方向可能具有挑战性。这就是为什么 MJCF 提供了几种替代机制。无论用户选择哪种机制，框架方向在内部始终转换为单位四元数。回想一下，围绕由单位向量 $(x, y, z)$ 给出的轴旋转角度 $a$ 的三维旋转对应于四元数 $(\cos(a/2), \sin(a/2)\cdot(x, y, z))$。也请记住，每个三维方向都可以由围绕某个轴的某个角度的单个三维旋转唯一指定。

所有具有空间框架的 MJCF 元素都允许下面列出的五个属性。框架方向最多使用其中一个属性指定。quat 属性具有对应于零旋转的默认值，而其他属性则初始化为特殊的未定义状态。因此，如果用户未指定这些属性中的任何一个，则框架不会旋转。

> quat: real(4), "1 0 0 0"
>  
> 如果已知四元数，这是指定框架方向的首选方式，因为它不涉及转换。相反，它在编译期间被标准化为单位长度并复制到 mjModel 中。当模型保存为 MJCF 时，所有框架方向都使用此属性表示为四元数。

> axisangle: real(4), 可选
>  
> 这些是上面提到的量 $(x, y, z, a)$。最后一个数字是旋转角度，以度或弧度表示，由编译器的 angle 属性指定。前三个数字确定一个三维向量，即旋转轴。该向量在编译过程中被标准化为单位长度，因此用户可以指定任何非零长度的向量。请记住，旋转是右手的；如果向量 $(x, y, z)$ 的方向相反，将导致相反的旋转。改变 $a$ 的符号也可用于指定相反的旋转。

> euler: real(3), 可选
>  
> 围绕三个坐标轴的旋转角度。应用这些旋转的轴序列由编译器的 eulerseq 属性确定，并且对整个模型都相同。

> xyaxes: real(6), 可选
>  
> 前 3 个数字是框架的 X 轴。接下来的 3 个数字是框架的 Y 轴，它会自动变得与 X 轴正交。Z 轴随后定义为 X 轴和 Y 轴的叉积。

> zaxis: real(3), 可选
>  
> 框架的 Z 轴。编译器找到将向量 $(0, 0, 1)$ 映射到此处指定的向量的最小旋转。这隐式地确定了框架的 X 和 Y 轴。这对于具有围绕 Z 轴的旋转对称性的几何体以及沿着其框架 Z 轴定向的光源很有用。

## 求解器参数

"计算"章节的"求解器参数"部分解释了决定 MuJoCo 中约束行为的量 $d, b, k$ 的数学和算法含义。这里我们解释如何设置它们。设置是间接完成的，通过 solref 和 solimp 属性，这些属性在所有涉及约束的 MJCF 元素中都可用。这些参数可以按约束调整，或按默认类调整，或保持未定义——在这种情况下，MuJoCo 使用下面显示的内部默认值。还要注意 option 中可用的覆盖机制；它可以在运行时用于更改所有与接触相关的求解器参数，以便交互式地试验参数设置或实现数值优化的连续方法。

这里我们专注于单个标量约束。使用与"计算"章节略有不同的符号，让 $a_1$ 表示加速度，$v$ 表示速度，$r$ 表示位置或残差（在摩擦维度中定义为 0），$k$ 和 $b$ 表示用于定义参考加速度 $a_{ref}=-bv-kr$ 的虚拟弹簧的刚度和阻尼。让 $d$ 表示约束阻抗，$a_0$ 表示在没有约束力的情况下的加速度。我们先前的分析揭示了约束空间中的动态近似为：

$$a_1 + d \cdot (bv + kr) = (1 -d) \cdot a_0$$
$$a1 + d \cdot (bv + kr) = (1 - d) aO$$

再次强调，用户可以控制的参数是 $d, b, k$。其余量是系统状态的函数，并在每个时间步自动计算。

### 阻抗

我们先来解释约束阻抗 $d$。

::: info 阻抗的直观描述

阻抗 $d \in (0, 1)$ 对应于约束产生力的能力。$d$ 值较小对应于弱约束，而 $d$ 值较大对应于强约束。阻抗在任何时候都会影响约束，特别是当系统处于静止状态时。阻抗通过 `solimp` 属性进行设置。
:::

请记住，$d$ 必须在 0 和 1 之间；MuJoCo 内部将其限制在 [mjMINIMP mjMAXIMP] 范围内，目前设置为 [0.0001 0.9999]。它使求解器在无约束加速度 $a_0$ 和参考加速度 $a_{ref}$ 之间进行插值。用户可以将 $d$ 设置为常量，或利用其插值特性使其依赖于位置，即约束违反 $r$ 的函数。位置相关阻抗可用于建模物体周围的软接触层，或定义随着违反程度增大而变强的等式约束（例如用于近似齿隙）。函数 $d(r)$ 的形状由元素特定的参数向量 solimp 确定。

**solimp**: real(5), "0.9 0.95 0.001 0.5 2"

这五个数字 ($d_0$, $d_{width}$, $width$, $midpoint$, $power$) 参数化了 $d(r)$ ——阻抗 $d$ 作为约束违反 $r$ 的函数。

前 3 个值表示阻抗将随着 $r$ 从 $0$ 变化到 $width$ 而平滑变化：

$$d(0) = d_0, \quad d(width) = d_{width}$$

第 4 和第 5 个值，$midpoint$ 和 $power$，控制在 $d_0$ 和 $d_{width}$ 之间插值的 S 型函数的形状，如下面的图所示。图表显示了两个反射的 S 型函数，因为阻抗 $d(r)$ 依赖于 $r$ 的绝对值。$power$（用于生成函数的多项式样条的幂）必须大于或等于 1。$midpoint$（指定拐点）必须在 0 和 1 之间，并以 $width$ 为单位表示。请注意，当 $power$ 为 1 时，无论 $midpoint$ 如何，函数都是线性的。

![](https://mujoco.readthedocs.io/en/stable/_images/impedance_dark.png)

这些图表在垂直轴上显示阻抗 $d(r)$，作为水平轴上约束违反 $r$ 的函数。

对于等式约束，$r$ 是约束违反。对于限制、椭圆锥的法线方向和锥形锥的所有方向，$r$ 是（限制或接触）距离减去约束变为活跃的边界；对于接触，此边界为 margin-gap。当 $r < 0$（穿透）时，限制和接触约束变为活跃。

对于摩擦损失或椭圆锥的摩擦维度，违反 $r$ 恒等于零，因此只有 $d(0)$ 影响这些约束，所有其他 solimp 值都被忽略。

::: info 平滑性和可微性

为了获得完全平滑（可微）的动力学，限制和接触应该设置 $d_0 = 0$（solimp[0]=0）。特别是对于接触，应记住几何体相关求解器参数的混合规则。另请参阅"计算"章节中关于导数的讨论以及 mjd_transitionFD 文档。
:::

### 参考加速度

接下来我们解释刚度 $k$ 和阻尼 $b$ 的设置，它们控制参考加速度 $a_{ref}$。

::: info 参考加速度的直观描述

参考加速度 $a_{ref}$ 决定了约束为了纠正违反而试图实现的运动。想象一个物体掉落到平面上。撞击时，约束将产生法向力，试图通过特定运动来纠正穿透；这种运动就是参考加速度。

理解参考加速度的另一种方式是考虑"计算"章节中描述的未建模变形变量。想象两个物体被压在一起，导致接触处发生变形。现在快速拉开这两个物体；变形回到未变形状态时的运动就是参考加速度。

这个加速度由两个数值定义：刚度 $k$ 和阻尼 $b$，它们可以直接设置，也可以重新参数化为质量-弹簧-阻尼系统（谐振子）的时间常数和阻尼比。参考加速度通过 solref 属性控制。
:::

该属性有两种格式，由数值的符号确定。如果两个数值都是正数，则规范被认为是 $(timeconst, dampratio)$ 格式。如果是负数，则是"直接" $(-stiffness, -damping)$ 格式。

残差恒等于 0 的摩擦约束具有一阶动力学，下面的质量-弹簧-阻尼分析不适用。在这种情况下，时间常数是约束速度指数衰减的速率，阻尼比被忽略。等效地，在直接格式中，刚度被忽略。

**solref**: real(2), "0.02 1"

我们首先描述默认的正值格式，其中两个数字是 $(timeconst, dampratio)$。

这里的思路是根据质量-弹簧-阻尼系统的时间常数和阻尼比重新参数化模型。这里的"时间常数"是指固有频率乘以阻尼比的倒数。在这种情况下，我们使用质量-弹簧-阻尼模型在适当缩放后计算 $k, b$。请注意，有效刚度 $d(r) \cdot k$ 和阻尼 $d(r) \cdot b$ 都被阻抗 $d(r)$ 缩放，而阻抗是距离 $r$ 的函数。因此我们不能总是实现指定的质量-弹簧-阻尼特性，除非我们通过 $d$ 完全消除缩放。但后者是不可取的，因为它会破坏插值特性，特别是极限 $d = 0$ 将不再能禁用约束。相反，我们缩放刚度和阻尼，使阻尼比保持恒定，而当 $d(r)$ 变小时时间常数增加。缩放公式为：

$$b = \frac{2}{d_{width} \cdot timeconst}$$

$$k = \frac{d(r)}{d_{width}^2 \cdot timeconst^2 \cdot dampratio^2}$$

timeconst 参数应该至少比仿真时间步长大两倍，否则相对于数值积分器，系统可能变得过于刚硬（特别是使用欧拉积分时），仿真可能变得不稳定。这在内部是强制执行的，除非 flag 的 refsafe 属性设置为 false。dampratio 参数通常设置为 1，对应于临界阻尼。较小的值会导致欠阻尼或弹跳约束，而较大的值会导致过阻尼约束。将上述公式与 (1) 结合，我们可以得出以下结果。如果参考加速度使用正数格式给出，且阻抗为常数 $d = d_0 = d_{width}$，则静止时的穿透深度为：

$$r = a_0 \cdot (1-d) \cdot timeconst^2 \cdot dampratio^2$$

接下来我们描述直接格式，其中两个数字是 $(-stiffness, -damping)$。这允许特别是对回弹的直接控制。我们仍然应用一些缩放，以便相同的数字可以用于不同的阻抗，但缩放不再依赖于 $r$，两个数字也不再相互作用。缩放公式为：

$$b = \frac{damping}{d_{width}}$$

$$k = \frac{stiffness \cdot d(r)}{d_{width}^2}$$

与上述推导类似，如果参考加速度使用负数格式给出且阻抗为常数，则静止时的穿透深度为：

$$r = \frac{a_0(1-d)}{stiffness}$$

::: tip 提示

在正值默认格式中，timeconst 参数控制约束软度。它以时间为单位指定，意思是"约束试图多快解决违反"。较大的值对应于较软的约束。

负值"直接"格式更加灵活，例如允许完全弹性碰撞（damping = 0）。这是系统识别的推荐格式。

正值格式中的 dampratio = 1 等效于直接格式中的 damping = 2√stiffness。
:::

### 接触参数

每个接触的参数在"计算"章节的"接触"部分已有描述。这里我们解释如何设置这些参数。如果几何体对是通过 XML 元素 pair 显式定义的，它具有直接指定所有接触参数的属性。在这种情况下，单个几何体的参数会被忽略。另一方面，如果接触是通过动态机制生成的，则需要从接触对中的两个几何体推断其参数。如果两个几何体具有相同的参数，则无需处理，但如果它们的参数不同怎么办？在这种情况下，我们使用几何体属性 solmix 和 priority 来决定如何组合它们。每个接触参数的组合规则如下：

condim

> 如果两个几何体中有一个具有更高的优先级，则使用其 condim。如果两个几何体具有相同的优先级，则使用两个 condim 的最大值。这样，无摩擦几何体和有摩擦几何体形成有摩擦接触，除非无摩擦几何体具有更高的优先级。后者在粒子系统中是可取的，例如，我们可能不希望粒子粘附到任何物体上。

friction

> 回想一下，接触最多可以有 5 个摩擦系数：两个切向、一个扭转、两个滚动。mjData.contact 中的每个接触实际上都有所有 5 个系数，即使 condim 小于 6 且并非所有系数都被使用。相比之下，几何体只有 3 个摩擦系数：切向（两个轴相同）、扭转、滚动（两个轴相同）。这些摩擦系数的 3D 向量通过复制切向和滚动分量扩展为 5D 向量。有关切向、扭转和滚动系数语义的直观描述，请参阅"计算"章节中的"接触"部分。

> 然后根据以下规则计算接触摩擦系数：如果两个几何体中有一个具有更高的优先级，则使用其摩擦系数。否则，使用两个几何体上每个摩擦系数的逐元素最大值。

> 每个接触有 5 个系数而每个几何体只有 3 个系数的原因如下。对于接触对，我们希望允许求解器能够处理的最灵活的模型。如前所述，各向异性摩擦可以用来建模滑冰等效果。但这需要知道接触切平面的两个轴是如何定向的。对于预定义的接触对，我们预先知道两个几何体类型，相应的碰撞函数总是生成以相同方式定向的接触框架——我们在这里不详细描述，但可以在可视化器中看到。然而，对于单个几何体，我们不知道它们可能与哪些其他几何体碰撞以及它们的几何体类型可能是什么，因此在指定单个几何体时无法知道接触切平面将如何定向。这就是为什么 MuJoCo 不允许在单个几何体规范中使用各向异性摩擦，而只允许在显式接触对规范中使用。

margin, gap

> 使用两个几何体边界（或间隙）的最大值。这里忽略几何体优先级，因为边界和间隙是距离属性，单方面规范意义不大。

solref, solimp

> 如果两个几何体中有一个具有更高的优先级，则使用其 solref 和 solimp 参数。如果两个几何体具有相同的优先级，则使用加权平均值。权重与 solmix 属性成正比，即 weight1 = solmix1 / (solmix1 + solmix2)，weight2 类似。这个加权平均规则有一个重要例外。如果任一几何体的 solref 为非正值，即它依赖于直接格式，则无论 solmix 如何，都使用逐元素最小值。这是因为对不同格式的 solref 参数进行平均是没有意义的。

### 接触覆盖

MuJoCo 使用了一套精细且新颖的约束模型，详见"计算"章节。要直观理解该模型的工作原理需要一些实验。为了促进这一过程，我们提供了一种覆盖部分求解器参数的机制，无需对实际模型进行更改。一旦禁用覆盖，仿真就会恢复到模型中指定的参数。这种机制还可以用于在数值优化（如最优控制或状态估计）的背景下实现延续方法。通过在优化的早期阶段允许接触从远距离起作用——以帮助优化器找到梯度并接近良好解——然后减少这种效果以使最终解在物理上更真实。

这里的相关设置是 flag 的 override 属性（启用和禁用此机制），以及 option 的 o_margin、o_solref、o_solimp 属性（指定新的求解器参数）。注意覆盖仅适用于接触，不适用于其他类型的约束。原则上，MuJoCo 模型中有许多实值参数都可以从类似的覆盖机制中受益。但我们必须在某处划线，而接触是自然的选择，因为它们产生了最丰富但最难调整的行为。此外，接触动力学经常在数值优化方面提出挑战，经验表明，对接触参数的延续可以帮助避免局部最小值。

### 用户参数

许多 MJCF 元素都有可选属性 user，它定义了一个自定义的元素特定参数数组。这与 size 元素的相应"nuser_XXX"属性相互作用。例如，如果我们将 nuser_geom 设置为 5，那么 mjModel 中的每个 geom 都将有一个包含 5 个实值参数的自定义数组。这些 geom 特定参数要么通过 geom 的 user 属性在 MJCF 文件中定义，要么在省略此属性时由编译器设置为 0。所有"nuser_XXX"属性的默认值是 -1，这指示编译器自动将此值设置为模型中定义的最大关联 user 属性的长度。MuJoCo 不会在任何内部计算中使用这些参数；相反，它们可用于自定义计算。解析器允许 XML 中的任意长度数组，编译器稍后将它们调整为长度 nuser_XXX。

通常用于内部计算的一些元素特定参数也可以用于自定义计算。这通过安装覆盖仿真管道部分的用户回调来完成。例如，通用执行器元素具有属性 dyntype 和 dynprm。如果 dyntype 设置为"user"，那么 MuJoCo 将调用 mjcb_act_dyn 来计算执行器动力学，而不是调用其内部函数。由 mjcb_act_dyn 指向的用户函数可以按其意愿解释 dynprm 中定义的参数。但是这个参数数组的长度不能更改（与前面描述的自定义数组不同，后者的长度在 MJCF 文件中定义）。这同样适用于其他回调。

除了上述元素特定的用户参数，还可以通过自定义元素在模型中包含全局数据。对于在仿真过程中发生变化的数据，还有数组 mjData.userdata，其大小由 size 元素的 nuserdata 属性确定。

### 求解器设置

约束力和约束加速度的计算涉及数值求解优化问题。MuJoCo 有三种算法来求解这个优化问题：CG、Newton、PGS。每种算法都可以应用于摩擦锥的锥形或椭圆模型，以及稠密或稀疏约束雅可比矩阵。此外，用户可以指定最大迭代次数和控制早期终止的容差水平。还有第二个 Noslip 求解器，这是一个后处理步骤，通过指定正数的无滑移迭代次数来启用。所有这些算法设置都可以在 option 元素中指定。

默认设置对大多数模型都运行良好，但在某些情况下需要调整算法。最好的方法是实验相关设置并使用 simulate.cc 中的可视化分析器，它显示不同计算的时间以及每次迭代的求解器统计信息。我们可以提供以下一般指导原则和观察：

* 约束雅可比矩阵对于小模型应该是稠密的，对于大模型应该是稀疏的。默认设置是'auto'；当自由度数量不超过 60 时解析为稠密，超过 60 时为稀疏。但是请注意，阈值最好根据活跃约束的数量来定义，这取决于模型和行为。
* 锥形和椭圆摩擦锥之间的选择是建模选择而不是算法选择，即它导致用相同算法求解的不同优化问题。椭圆锥更接近物理现实。但是锥形锥可以改善算法性能——但不一定。虽然默认是锥形，我们建议尝试椭圆锥。当接触滑移是问题时，抑制它的最好方法是使用椭圆锥、大的 impratio 和具有非常小容差的 Newton 算法。如果这还不够，启用 Noslip 求解器。
* Newton 算法是大多数模型的最佳选择。它在全局最小值附近具有二次收敛性，并在令人惊讶的少数迭代中到达那里——通常约 5 次，很少超过 20 次。它应该与激进的容差值一起使用，比如 1e-10，因为它能够在不增加延迟的情况下实现高精度（由于最后的二次收敛）。我们见过它减慢的唯一情况是具有椭圆锥和许多滑移接触的大模型。在该状态下，Hessian 分解需要大量更新。在某些大模型中，如果模型元素的不幸排序导致高填充，它也可能减慢（计算最优消除顺序是 NP 困难的，所以我们依赖启发式）。请注意可以在分析器中监控分解 Hessian 中非零元素的数量。
* CG 算法在上述 Newton 减慢的情况下运行良好。一般来说，CG 显示出具有良好速率的线性收敛，但在迭代次数方面无法与 Newton 竞争，特别是当需要高精度时。但是它的迭代要快得多，不受填充或椭圆锥增加复杂性的影响。如果 Newton 被证明太慢，接下来尝试 CG。
* 当自由度数量大于约束数量时，PGS 求解器是最佳的。PGS 求解约束优化问题，根据我们的经验具有次线性收敛，但它通常在前几次迭代中取得快速进展。所以当可以容忍不准确解时，它是一个好选择。对于具有大质量比或其他导致条件不良的模型属性的系统，PGS 收敛往往相当慢。请记住，PGS 执行顺序更新，因此在物理应该对称的系统中破坏对称性。相比之下，CG 和 Newton 执行并行更新并保持对称性。
* Noslip 求解器是一个修改的 PGS 求解器。它作为主求解器（可以是 Newton、CG 或 PGS）之后的后处理步骤执行。主求解器更新所有未知数。相比之下，Noslip 求解器只更新摩擦维度中的约束力，并忽略约束正则化。这具有抑制由软约束模型引起的漂移或滑移的效果。但是，这种优化步骤的级联不再求解明确定义的优化问题（或任何其他问题）；相反，它只是一个临时机制。虽然它通常完成其工作，但我们在具有多个接触之间更复杂相互作用的模型中见过一些不稳定性。
* PGS 在计算约束空间中的逆惯性方面有设置成本（在 CPU 时间方面）。类似地，Newton 对 Hessian 的初始分解有设置成本，并根据稍后需要多少分解更新而产生额外的分解成本。CG 没有任何设置成本。由于 Noslip 求解器也是 PGS 求解器，每当启用 Noslip 时都将支付 PGS 设置成本，即使主求解器是 CG 或 Newton。主 PGS 和 Noslip PGS 的设置操作是相同的，因此当两者都启用时，设置成本只支付一次。

### 执行器

本节描述在 MuJoCo 中使用执行器的各个方面。有关计算模型，请参阅[执行模型](https://mujoco.readthedocs.io/en/stable/computation/index.html#geactuation)。

#### 组禁用

[actuatorgroupdisable](https://mujoco.readthedocs.io/en/stable/XMLreference.html#option-actuatorgroupdisable) 属性可以在运行时通过设置 [mjOption.disableactuator](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjoption) 整数位字段来更改，允许用户根据执行器的组来禁用执行器集合。当希望为同一运动学树使用多种类型的执行器时，此功能很方便。例如，考虑一个具有支持多种控制模式（如扭矩控制和位置控制）固件的机器人。在这种情况下，可以在同一个 MJCF 模型中定义两种类型的执行器，将一种类型的执行器分配给组 0，将另一种分配给组 1。

[actuatorgroupdisable](https://mujoco.readthedocs.io/en/stable/XMLreference.html#option-actuatorgroupdisable) MJCF 属性选择默认禁用哪些组，[mjOption.disableactuator](https://mujoco.readthedocs.io/en/stable/APIreference/APItypes.html#mjoption) 可以在运行时设置以切换活跃集合。请注意，执行器总数 `mjModel.nu` 保持不变，执行器索引也是如此，因此用户需要知道被禁用执行器的相应 `mjData.ctrl` 值将被忽略且不产生力。此[示例模型](https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/actuation/actuator_group_disable.xml)有三个执行器组，可以在模拟交互式查看器中运行时切换。

#### 快捷方式

如"计算"章节的执行模型部分所解释的，MuJoCo 提供了一个灵活的执行器模型，其传动、激活动力学和力生成组件可以独立指定。完整功能可以通过 XML 元素 general 访问，允许用户创建各种自定义执行器。此外，MJCF 提供了配置常见执行器的快捷方式。这通过 XML 元素 motor、position、velocity、intvelocity、damper、cylinder、muscle 和 adhesion 完成。这些不是独立的模型元素。在内部，MuJoCo 只支持一种执行器类型——这就是为什么当保存 MJCF 模型时，所有执行器都写为 general。快捷方式隐式创建 general 执行器，将其属性设置为合适的值，并暴露可能具有不同名称的属性子集。例如，position 创建一个位置伺服，具有属性 kp，它是伺服增益。但是 general 没有属性 kp。相反，解析器以协调的方式调整 general 执行器的增益和偏置参数，以模拟位置伺服。同样的效果可以通过直接使用 general 并将其属性设置为某些值来实现，如下所述。

执行器快捷方式也与默认值交互。回想一下，默认设置机制涉及类，每个类都有一个完整的虚拟元素集合（每种元素类型一个），用于初始化实际模型元素的属性。特别是，每个默认类只有一个 general 执行器元素。如果我们在同一个默认类中先指定 position 然后指定 velocity 会发生什么？XML 元素按顺序处理，每当遇到与执行器相关的元素时，单个 general 执行器的属性就会被设置。因此 velocity 具有优先权。但是，如果我们在默认类中指定 general，它只会设置明确给出的属性，而其余的保持不变。在创建实际模型元素时会出现类似的复杂情况。假设活跃默认类指定了 position，现在我们使用 general 创建执行器并省略其某些属性。缺失的属性将设置为用于建模位置伺服的任何值，即使此执行器可能不打算作为位置伺服。

鉴于这些潜在的复杂性，我们建议一种简单的方法：在默认类和创建实际模型元素时使用相同的执行器快捷方式。如果给定模型需要不同的执行器，要么创建多个默认类，要么避免对执行器使用默认值，而是明确指定其所有属性。

#### 力限制

执行器力通常在下限和上限之间受限。这些限制可以通过三种方式强制执行：

**使用 [ `ctrlrange` ](https://mujoco.readthedocs.io/en/stable/XMLreference.html#actuator-general-ctrlrange) 进行控制钳制：**

> 如果设置了此执行器属性，输入控制值将被钳制。对于简单[电机](https://mujoco.readthedocs.io/en/stable/XMLreference.html#actuator-motor)，钳制控制输入等效于钳制力输出。

**使用 [forcerange](https://mujoco.readthedocs.io/en/stable/XMLreference.html#actuator-general-forcerange) 在执行器输出处进行力钳制：**

> 如果设置了此执行器属性，执行器的输出力将被钳制。此属性对[位置执行器](https://mujoco.readthedocs.io/en/stable/XMLreference.html#actuator-position)等很有用，可以将力保持在界限内。请注意，位置执行器通常还需要控制范围钳制以避免触及关节限制。

**使用 [joint/actuatorfrcrange](https://mujoco.readthedocs.io/en/stable/XMLreference.html#body-joint-actuatorfrcrange) 在关节输入处进行力钳制：**

> 此关节属性钳制作用在关节上的所有执行器输入力，经过传动后。在关节处钳制执行器力等效于在执行器处钳制它们，如果传动是简单的（执行器和关节之间存在一对一关系）。但是，在多个执行器作用在一个关节或一个执行器作用在多个关节的情况下——而实际扭矩是由关节处的单个物理执行器施加的——希望在关节本身钳制力。以下是三个示例，其中希望在关节而不是执行器处钳制执行器力：
>
> * 在此[示例模型](https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/actuation/joint_force_clamp.xml)中，两个执行器（电机和阻尼器）作用在单个关节上。
> * 在此[示例模型](https://github.com/google-deepmind/mujoco/blob/main/model/car/car.xml)中（类似于"Dubin's Car"），两个执行器通过固定腱传动作用在两个轮子上，以施加对称（向前/向后滚动）和反对称（向右/向左转动）扭矩。
> * 在此[示例模型](https://github.com/google-deepmind/mujoco/tree/main/test/engine/testdata/actuation/refsite.xml)中，位点传动实现了手臂末端执行器的笛卡尔控制器。为了使计算的扭矩能够由单个、扭矩受限的关节电机实现，它们需要在关节处被钳制。
>
> 请注意，在这种情况下，力/扭矩由传动组合，应使用 jointactuatorfrc 传感器来报告作用在关节上的总执行器力。标准 actuatorfrc 传感器将继续报告预钳制执行器力。

**使用 tendon/actuatorfrcrange 在腱输入处进行力钳制：**

> 此腱属性钳制作用在腱上的所有执行器输入力。

上述钳制选项是非排他的，可以根据需要组合使用。
